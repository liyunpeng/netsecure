
发生死锁 意味着四个条件同时满足了， 避免死锁就要从这四个条件入手。
1. 锁的互斥，就是只能由一个执行体使用。执行体可能是进城，线程，或携程，
 针对这个，分出不同的锁，读锁和写锁，读锁是可以允许读的执行体进来，减少互斥的发生，减少死锁概率。

2. 锁的不可剥夺，即锁只能被当前执行体释放，其他执行体无权释放 
针对这个特点, 可以设置锁等待超时，超时了，就自动释放锁，减少死锁概率.
redis和mysql数据库都有锁的时间超时措施， 
mysql的innodb引擎给每个锁都设置一个innodb_lock_wait_timeout， 
当上锁后，经过innodb_lock_wait_timeout时间后，
作为锁的持有者事务就会回滚， 
回滚到之前的状态，这样其他事务就可以拿到这个锁。 
redis有setnx有超时设置，但不支持回滚，需要应用程序自己维护回到之前的状态。

3. 锁的保持，锁被占有后，总会被保持一段时间
针对这一点，在上锁和解锁之间的动作，尽可能的少，尽可能的快，事务里的动作要尽可能的少。 

4. 锁的循环等待，进入B资源的锁被另一个事务2持有，而事务2进入A资源的锁又被事务1持有，造成循环等待 
针对这个， 规定每个事物对资源的操作，确保顺序相同  
比如：
事务一先对记录A操作，再对记录B操作， 
事务二也要按先操作记录A，后操作记录B的顺序。 

---

上锁次数：
当删除或修改数据时innodb引擎会自动上锁。即 where 后面的列要上锁。 
根据这个列的索引的类型，或是否为索引，上锁的次数也会不同。 

1. 查询列是聚集索引
聚集索引的实现是B+树 叶子节点包含了一行的所有列。 
如果这个列是聚集索引只需要锁住这个B+树的一个叶子节点行 所以只锁一次

2. 查询列是二级索引
二级索引除聚集索引其他索引 都可以叫做二级索引 
因为二级索引存放的索引值和聚集索引的键值, 不存放其他列值用这个聚集索引的键到B+树上去找叶子节点 
所以where 后的列如果是二级索引需要两个加锁动作。 
一个动作是锁二级索引的B树节点 一个动作是锁聚集索引的B+树节点。 

3. 查询列不是索引
如果列不是索引 需要全表扫描过滤 全表扫描以为着对所有的数据行都加锁。 
所以对于大量数据行的表 where后面的列必须建立索引。 

所以尽可能使用聚集索引的列作为where条件
对where查询列如果不是索引，要建立索引，减少死锁概率

---

gap锁 因为加锁的范围大增加了死锁的概率 
如果在业务上能保证一个事务没有第二次读的问题 就可以把隔离级别从RR降到RC
将隔离级别从RR调整为RC， 可以降低gap锁引起的死锁问题。
