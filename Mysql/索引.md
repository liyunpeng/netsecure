 数据库的主要技术，就是数据的快速查询更新， 同时保证安全。 基本所有的技巧都是围绕着这两点。 索引就是为了第一点  
 论快速：  
 数据库为快做了努力， redis通过缓存为快做了努力， 集群通过多台机器并行处理大量用户相同的请求为快做出努力， 分布式把一个服务拆分成几个模块， 几个模块同时进行， 最后组合出用户要的服务结果。  
 微服务可以一个服务拆分成很多个微小的服务， 各服务通过rpc同时进行， 最后组合出用的服务结果， 最终实现每秒对百万用户的请求
 为了快速查询，就有索引。
 避免全表扫描，b+树的一个节点存放多个关键字值，
 b+树可以存放1200多个个关键字， 成为1200的多路查找树，大大减少磁盘io的次数。 
## 一. 索引
### 1. 聚集索引
叶子节点里面只存放索引的值，
select 后面跟的字段， 可以多，可以少， 如果是* ， 就是这一行的全部字段，
这种情况， 如果是聚集索引， 可以不用更具索引中行的地址的值到表中找数据，
根据索引提供的行的地址到表中招数据的动作， 称为回表。
因为聚集索引的B+树叶子节点存放了完整的数据行， 所以用聚集索引完全不用回表。
而非聚集索引， 叶子节点仅存放的事作为索引的列的值，
用非聚集索引查询时， 是否回表， 就要看查询列是否只有索引的列，
如果只是索引的列， 就不需要回表
除聚集索引， 其他都叫非聚集索引，或二级索引。 如唯一索引， 复合索引都属于二级索引，

### 2. 覆盖索引
 这种查询列都是索引因的查询， 叫做覆盖索引查询

### 3. 联合索引
主键联合索引是主键由两个列组成， 两个列共同组成了主键， 比如订单号和商品号
这张联合索引只有在myisam引擎里有， 因为innodb的主键是聚集索引
没增加一个， 其物理顺序递增，  这样避免插入一条记录，
引起B+树的大规模的物理顺序调整。 增加了插入时间的时间

### 4. 有索引，确不走索引的情况
不走索引的几种情况
建立了索引， 但实际中没有使用索引的场景要清楚， 列一下：

* 看执行计划确定是否走索引
  建立了索引， 不代表实际中就使用了索引， 要看mysql的执行计划， 优化器会有个判断，

* 外层循环
 两层查询， 外层循环都是一个范围查询，索引时用不上的， 索引只能相等条件的查询，
 不可避免的扫描表，即回表，
 内层查询， 如果是索引咧查询， 就可以用icp机制， 在外层循环的结果集查询，交给存储引擎去做， 避免了回表

* 当表中的记录个数不是很多时， 扫描全表比去去索引中查找记录的位置更快， 这时优化器就不会使用索引。

* 类型不匹配， 本来时数字索引，用了字符，也不走索引

* 模糊查询
  使用like待百分号的模糊查询， 查询列是索引， 是否使用用索引要%的位置，   
  如果在末尾， 则使用索引， 其他位置都不使用索引。 在最末尾， 表示只搜索开头的几个字符。
还有几种情况， 不清楚TODO
### 影响查询速度的其他因素
有时速度不仅和索引有关，还有和缓冲区有关，可以show命令，
 查看缓冲区的命中数，除以总的查询数，可以算出命中率。
 这个要维持在一定的百分比，如果低于设定的百分比，说明缓存设置的太小。
 还有慢查询的show, 默认超过两秒的查询可以被show 统计出。
 
## 二. 建立索引的技巧
索引最好不要字符串，要用数字，前缀索引， 复合索引等叙述，用查找快速， 更新容易的目的把技术穿起来
* 索引的个数不应该过多， 控制在5个以内  
  因为多建立一个索引， 在数据插入和更新时， 就要维护这个索引数据结构。

* 尽量在数字列建立索引
为了在索引树比较的快速，作为索引的字段类型尽量用数字类型，不用字符传类型，字符串要逐个字符比较，
建立索引的列最好是数字类型， 这样在索引树上查找时， 每个节点只做一次匹配操作，  
如果是字符串， 需要把每个字符都捉个匹配， 匹配的次数就是字符串的长度，

* 字符串索引尽量用前缀索引
如果非得一定要建立字符串的索引，就把字符串的个数尽可能的减少，比如只选出前8个字符比较 有针对这种情况的前缀索引，  只要前面的8个字符， 建立索引，  语句大概是
```
 alter table tabel1 index indexa ( 列名（8))
```
* 用复合索引
 一般选择三个列， 最多不超过5个列。 为了限制住索引的数目， 可以考虑把3个列的索引变成一个索引。  这样索引的总数减少了2个。  查询列里面必须包含最左列， 否则不走索引，  
复合索引，因为在插入和更新数据时都要维护索引树，一个索引对应一个索引树， 一般控制在5个以内，复合索引把多个索引放在一个索引里面，减少了索引的个数。

* 有时需要where 和order by一起使用， 则where的必须是最坐列， 否则不走索引。
 
* 建立索引的字段类型要设置为非空
 为了查询的快速， 建表时可以规范， 字段非空的。

* 两个表联合时，union all 的速度远大于union的速度是，因为uniion要去除重复的记录。

 


