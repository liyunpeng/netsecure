锁的争夺情况，当前连接数，缓存的命中个数，等都属于数据库的状态， 可以用show 来查询
设置用virable, 使用情况用status查看。 


字段类型非空，
索引最好不要字符串，要用数字，前缀索引， 复合索引等叙述，用查找快速， 更新容易的目的把技术穿起来

数据库的主要技术， 是数据的快速查询和更新。同时保证安全。 基本所有的技巧都是围绕着这几个点。 
为了快速查询，就有索引。 
避免全表扫描，b+树的一个节点存放多个关键字值，
b+树可以存放1200多个个关键字， 成为1200的多路查找树，大大减少磁盘io的次数。  

复合索引，因为在插入和更新数据时都要维护索引树，一个索引对应一个索引树， 一般控制在5个以内，复合索引把多个索引放在一个索引里面，减少了索引的个数。
为了在索引树比较的快速，作为索引的字段类型尽量用数字类型，不用字符传类型，字符串要逐个字符比较， 

如果用字符串索引，最好用前置索引，比如只选出前8个字符比较。 
为了查询的快速， 建表时可以规范， 字段非空的。 

两个表联合时，union all 的速度远大于union的速度是，因为uniion要去除重复的记录。 
有时速度不尽来自索引，还有和缓冲区，可以show命令， 
查看缓冲区的命中数，除以总的查询数，可以算出命中率。 
这个要维持在一定的百分比，如果低于设定的百分比，说明缓存设置的太小。 
还有慢查询的show, 默认超过两秒的查询可以被show 统计出。 
论快速：
数据库为快做了努力， redis通过缓存为快做了努力， 集群通过多台机器并行处理大量用户相同的请求为快做出努力， 分布式把一个服务拆分成几个模块， 几个模块同时进行， 最后组合出用户要的服务结果。  微服务可以一个服务拆分成很多个微小的服务， 各服务通过rpc同时进行， 最后组合出用的服务结果， 最终实现每秒对百万用户的请求



锁
数据库中的锁就是为了配和事务出现的

最小粒度的锁就是行锁， 粒度越小，需要的代价的动作就越多， 
通常数据库的autocommit默认是1，
不需要显示开启事务
实际的程序需要显示开启事务
事务要尽量的短小， 渠道数据马上退出， 不要做任何和数据无关的操作， 
在事务的整个期间， 锁不会因为sql语句的结束了
锁的生命周期是伴随整个事务的
锁从读写就读， 分为读锁和写锁， 又叫共享锁和排他锁
默认的select语句都是不带锁的恶， 
insert语句是排他锁， 

可以在sql语句显示

innodb 如果要统计行数， 扫描全表， 如果是count(主键)， TODO
需要不能关注的：
存储过程， 自定义函数， 都会使数据库操作把业务耦合进去， 
所以不能用， 
事务要最简单，最快，这才是高并发的正确思想指导

myisqm只有表锁， 所以不支持事务


分布式数据库：
TiDB 在摩拜单车的深度实践及应用 - 数据库-炼数成金-Dataguru...
https://yq.aliyun.com/articles/676098

oltp olap
https://www.cnblogs.com/lingchen-liang/p/10690619.html

https://blog.csdn.net/qq_33414271/article/details/81149966
