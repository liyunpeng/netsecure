### 一. 三种数据访问并发问题
在数据库中，并发控制是指在多个用户/进程/线程同时对数据库进行操作时，
如何保证事务的一致性和隔离性的，同时最大程度地并发。
当多个用户/进程/线程同时对数据库进行操作时，会出现3种冲突情形：  

>读-读，不存在任何问题  
>读-写，有隔离性问题，可能遇到脏读（会读到未提交的数据） ，幻影读等。  
>写-写，可能丢失更新要解决冲突，  

### 二. 解决并发的策略

#### 1. 重量级锁，
即基于锁的并发控制，比如2PL，这种方式开销比较高，而且无法避免死锁。

#### 2. 轻量级锁， 即乐观并发控制
乐观并发控制（OCC）是一种用来解决写-写冲突的无锁并发控制，  
认为事务间争用没有那么多，所以先进行修改，  
在提交事务前，检查一下事务开始后，有没有新提交改变，如果没有就提交，  
如果有就放弃并重试。  
乐观并发控制类似自选锁。  
乐观并发控制适用于低数据争用，写冲突比较少的环境。 
如果数据争用太过频繁， 同事访问的概率太大， 乐观自旋的代价就会很大。 会占用很大的cpu资源， 导致系统响应变慢。  

#### 3. 多版本并发控制

##### 3.1 多版本并发控制的作用
多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，  
也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，  
读操作只读该事务开始前的数据库的快照。  
这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，  
避免了脏读和不可重复读。
多版本并发控制可以结合基于锁的并发控制来解决写-写冲突，即MVCC+2PL，也可以结合乐观并发控制来解决写-写冲突。``
innodb 则只对读无锁，写操作仍是上锁的悲观并发控制，
这也意味着，innodb 中只能见到因死锁和不变性约束而回滚，而见不到因为写冲突而回滚；  
不像 postgres 那样对数据修改在表中创建新纪录，而是每行数据只在表中保留一份，在更新数据时上行锁，同时将旧版数据写入 undo log；  
表和 undo log 中行数据都记录着事务ID，在检索时，只读取来自当前已提交的事务的行数据；  
可见 MVCC 中的写操作仍可以按悲观并发控制实现，而 CAS 的写操作只能是乐观并发控制。


##### 3.2 多版本并发控制的实现
有MVCC的存储引擎会维护一个用作事务id的系统版本号， 和两个隐藏列。
* 系统版本号：  
    每开启一个新事务，系统版本号都会自动递增， 并且将系统版本号赋给事务id。  
    当前事务id标记为current_id。
* 当前事务id必须在两个隐藏列中间，当前事务才能看到这一行： 
```
create_id： 创建本行（就是插入记录）的事务的id, 标记为create_id 。
delete_id： 删除本行的事务的id， 标记为delete_id. 如果没有删除本行的事务， 那么delete_id为undefinde, 意为无限大。
```
能够被本次事务看到的行， 必须满足如下条件： 
```
create_id <= current_id
delete_id > current_id
```

* 本事务期间看到的表， 一定是本次事务开始时看到的表
create_id  和 delete_id限定了一个区间，  
current_id必须在这个区间里， 才能被当前事务看到。  
通过这两个隐藏列和事务Id的比较操作，就实现了快照。  
即保证了在本事务期间看到的表， 一定是本次事务开始时看到的表，即开始时的快照， 在本事务整个期间， 快照没有变化。  
本次事务期间， 其他事务对表做的插入记录， 删除记录，对于本次事务来说，都是无效操作 。
  
* mvcc用标记机制， 保证了事务看到的表， 是被自己独占的。
一个事务期间可以有多次select动作， 必须保证每次select看到的一样的。  
一个事务期间也会有更新记录， 插入记录，删除记录，mvcc保证了记录的隔离性。
简而言之， 在事务执行期间， 事务感觉到整个表是被自己独占的。 
锁表可以，但是性能代价太大， 其他事务完全是不可操作的， 在生产环境，是禁止的。 
mvcc就是不用锁的一种机制， 这样不会阻塞其他事务。 
mvcc用标记机制， 保证了事务看到的表， 是被自己独占的。  
读锁会把在执行增删改 的其他事务阻塞， 而mvcc不会让其他事务阻塞。 这是mvcc比读锁好的原因。
