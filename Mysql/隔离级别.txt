	
隔离级别：
事务A如果看到事务B还没提交的中间数据， 就是脏读
为解决这个问题， 就限定事务A只能读到事务B的已经提交的数据， 
这个措施是种隔离，即把没有提交的隔离出去， 不会被本事务看到， 这个隔离级别叫做读已提交， 
读已提交， 英文为read commited, 所以简称RC隔离级别

---------------
脏读解决了， 现在又来了另一个问题：
事务A在一行数据期间， 这一行数据正在被事务B修改，但事务B没提交这一行。
事务A读完了之后， 事务B把这行的修改提交了， 
事务A在第二次读这行数据时， 和第一次读到的结果不同， 
即两次读到的结果不同， 这个问题叫做不可重复读。 
为了解决这个不可重复读问题， 就有了另一种隔离级别，
新的隔离级别规定在事务A在读该行时，如果事务B要修改该行，那么不允许开启事务B， 以此保证事务A对该行所有读操作的结果都是相同的， 
这个隔离也因此得名， 叫做可重复读， 英文为repeadted read ， 简称RR隔离级别。 
RR级别是比较高的隔离级别， 会拖慢数据并发访问速度。 所以innodb默认情况下， 不开启RR隔离级别， 相应的事务尽量保证只有一次读数据， 尽量少的动作， 尽量少的时间退出事务。 

---------------
除了RC， RR两个隔离级别， 还有读未提交， 即RU隔离， 和序列化隔离。 
读未提交隔离，是没有任何措施的隔离， 等于没有隔离， 这个在myisam上默认使用， 所以myisam引擎数据访问比较。 
序列化隔离使得事务串行化，因为串行化， 严重拖慢并发问速度， 所以很少使用。 序列化可以解决幻读问题。 
不可重复读是对一个数据行的两次查询结果不同，
幻读是对一个连续范围多个数据行的两次查询结果不同。

----------------
隔离的实现， 有两种实现方式， 
一种是锁， 
一种是mvcc。
锁按规模分为， 表锁，和行锁， 
表锁上锁块， 行锁上锁慢
锁按操作性质分， 读锁， 和写锁， 
读锁又叫共享锁， s锁
写锁又叫排他锁。 
innoddb 默认在读数据时， 不上锁， 在修改数据时， 上写锁。 
mysql可用tx 开启事务， 
可以在配置文件设置隔离级别， 
因为不用串行化隔离级别， 事务并发执行， 
事务内部对数据行的访问顺序尽量保持一致， 
上锁的代价是比较高， 导致其他事务一直阻塞在那，又不睡眠， 又不释放cpu。 
锁基本就是现实中的锁， 一个人进入一间屋子， 上锁， 其他人都要在门口排队等待。 即不睡眠的盲等
mvcc实现隔离的方式， 每个事务都有版本号， 增加两个隐藏列， 分别一行数据
创建该行的事务的版本号， 和删除 该行事务的版本号。 
当前事务的版本号必须大于A版本号， 小于B版本号， A版本号相当于一个快照
事务操作的数据都都是在那个版本号时间点的数据， 
mvcc实现了事务的RR隔离级别。 
