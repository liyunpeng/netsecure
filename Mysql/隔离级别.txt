	
隔离级别：
事务A如果看到事务B还没提交的中间数据， 就是脏读
为解决这个问题， 就限定事务A只能读到事务B的已经提交的数据， 
这个措施是种隔离，即把没有提交的隔离出去， 不会被本事务看到， 这个隔离级别叫做读已提交， 
读已提交， 英文为read commited, 所以简称RC隔离级别

---------------
脏读解决了， 现在又来了另一个问题，即不可重复读
事务A在一行数据期间， 这一行数据正在被事务B修改，但事务B没提交这一行。
事务A读完了之后， 事务B把这行的修改提交了， 
事务A在第二次读这行数据时， 和第一次读到的结果不同， 
即两次读到的结果不同， 这个问题叫做不可重复读。 
为了解决这个不可重复读问题， 就有了另一种隔离级别，
新的隔离级别规定在事务A在读该行时，如果事务B要修改该行，那么不允许开启事务B， 以此保证事务A对该行所有读操作的结果都是相同的， 
这个隔离也因此得名， 叫做可重复读， 英文为repeadted read ， 简称RR隔离级别。 
RR级别是比较高的隔离级别， 会拖慢数据并发访问速度。 所以innodb默认情况下， 不开启RR隔离级别， 相应的事务尽量保证只有一次读数据， 尽量少的动作， 尽量少的时间退出事务。 

---
幻读问题 
与不可重复读问题比较，可更好理解幻读问题
不可重复读问题是：	两次查询到的结果是同一行，但行的内容不同了。 
幻读问题是：		两次查询到的结果是多个行，但行的个数不同了
比如where c = 1, 第一读到了一行 第二次读到了两行 在两次读期间 其他事务增加了一行。 

对于幻读问题， mysql解决方案：RR级别加gap锁 原理为
RR级别保证了同一行的安全， 
gap锁对所有满足where列查询的行都加锁，不允许对这些行进行添加和修改，是对满足where条件的多个行加锁，这其中也包括上锁时没出现的行
比如 where c = 1, 
如果添加的行中列c = 1, 这个添加动作就会被禁止。 
如果要把某一行的列c改为1，这个修改动作也会被禁止。
这就是gap锁。 


---------------
除了RC， RR两个隔离级别， 还有读未提交， 即RU隔离， 和序列化隔离。 
读未提交隔离，是没有任何措施的隔离， 等于没有隔离， 这个在myisam上默认使用， 所以myisam引擎数据访问比较。 

序列化隔离使得事务串行化，因为串行化， 严重拖慢并发问速度， 所以很少使用。 
序列化隔离可以解决幻读问题。 但很少用序列化解决。

----------------

隔离级别有两种实现方式， 
一种是锁， 
一种是mvcc。
锁按规模分为，表锁和行锁， 
表锁上锁块， 行锁上锁慢
锁按操作性质分，读锁和写锁， 
读锁又叫共享锁，S锁
写锁又叫排他锁。 
innodb引擎默认RR隔离级别，在读数据时不上锁，在修改数据时，上写锁。 
mysql语句可用tx开启事务， 
可以在配置文件设置隔离级别， 
一般不用串行化隔离级别，事务都是并发执行， 
事务内部对数据行的访问顺序尽量保持一致，以减少锁的循环等待，减少死锁概率。
上锁的代价是比较高的， 导致其他事务一直阻塞在那，又不睡眠，不能释放cpu。 
锁基本类似现实中的锁，一个人进入一间屋子，上锁，其他人都要在门口排队等待。而是是不睡眠的盲等

----
mvcc实现隔离的原理是，每个事务都有版本号， 增加两个隐藏列， 分别一行数据
创建该行的事务的版本号， 和删除 该行事务的版本号。 
当前事务的版本号必须大于A版本号， 小于B版本号， A版本号相当于一个快照
事务操作的数据都都是在那个版本号时间点的数据， 
mvcc实现了事务的RR隔离级别。 
