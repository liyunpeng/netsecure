　mysql等一些常见的关系型数据库的数据都存储在磁盘当中，在高并发场景下，业务应用对mysql产生的增删改查的操作造成的巨大的IO开销和查询压力，这无疑对数据库和服务器都是一种巨大的压力，为了解决此类问题，缓存数据的概念应运而生。极大的解决数据库服务器的压力，提高应用数据的响应速度。常见的缓存形式：内存缓存，文件缓存。

　　缓存数据是为了让客户端很少甚至不访问数据库服务器进行数据的查询，高并发下，能最大程度的降低对数据库服务器的访问压力。默认情况下：用户请求->数据查询->连接数据库服务器并查询数据->将数据缓存起来(html，内存，json，序列化数据)->显示给客户端；用户再次请求或者新用户访问->数据查询->直接从缓存中获取数据->显示给客户端

　　mysql的查询缓存：query_cache_type：查询缓存类型，有0,1,2三个取值，0则不使用查询缓存，1表示始终使用查询缓存，2表示按需使用查询缓存。query_cache_type为1时，亦可关闭查询缓存，SELECT SQL_NO_CACHE * FROM my_table WHERE condition。query_cache_type为2时，可按需使用查询缓存，SELECT SQL_CACHE * FROM my_table WHERE condition。query_cache_size：默认情况下为0，表示为查询缓存预留的内存为0，则无法使用查询缓存。SET GLOBAL query_cache_size = 134217728。查询缓存可以看做是SQL文本和查询结果的映射。第二次查询的SQL和第一次查询的SQL完全相同，则会使用缓存。SHOW STATUS LIKE 'Qcache_hits'; 查看命中次数。表的结构或数据发生改变时，查询缓存中的数据不再有效。清理缓存：FLUSH QUERY CACHE; //清理查询缓存内存碎片，RESET QUERY CACHE; //从查询缓存中移出所有查询，FLUSH TABLES; //关闭所有打开的表，同时该操作将会清空查询缓存中的内容

　　使用memcache缓存查询数据：对于大型站点，如果没有中间缓存层，当流量打入数据库层时，即便有之前的几层为我们挡住一部分流量，但是在大并发的情况下，还是会有大量请求涌入数据库层，这样对于数据库服务器的压力冲击很大，响应速度也会下降，因此添加中间缓存层很有必要。memcache是一套分布式的高速缓存系统，由livejournal的bradfitzpatrick开发，但目前被许多网站使用以提升网站的访问速度，尤其对于一些大型的，需要频繁访问数据库的网站访问速度提升效果十分显著。

　　memcache工作原理：是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，能够用来存储各种格式的数据，包括图像，视频，文件以及数据库检索的结果等，简单的说就是将数据调用到内存，然后从内存中读取，从而大大提高读取速度。

　　memcache工作流程：先检查客户端的请求数据是否在memcache中，如有，直接把请求数据返回，不再对数据库进行任何操作；如果请求的数据不在memcache中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcache中。

　　memcache方法：获取：get(key) 设置：set(key, val, expire) 删除：delete(key)

　　通用缓存机制：用查询的方法名+参数作为查询时的key value对中的key值

　　使用redis缓存查询数据：与memcache的区别：性能相差不大，redis在2.0版本后增加了自己的VM特性，突破物理内存的限制，memcache可以修改最大可用内存，采用LRU算法；redis依赖客户端来实现分布式读写，memcache本身没有数据冗余机制；redis支持快照，AOF，依赖快照进行持久化，aof增强了可靠性的同时，对性能有所影响，memcache不支持持久化，通常做缓存，提升性能；memcache在并发场景下，用cas保证一致性，redis事务支持比较弱，只能保证事务中的每个操作连续执行；redis支持多种类的数据类型；redis用于数据量较小的高性能操作和运算上，memcache用于在动态系统中减少数据库负载，提升性能，适合做缓存，提高性能

　　缓存其他数据：session：session_set_save_handler