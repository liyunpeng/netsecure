## 
HTTP缓存机制：如果请求成功会有三种情况：
* 200 from cache：直接从本地缓存中获取相应，最快速，最省流量，因为根本没有向服务器进行请求；

* 304 not modified：协商缓存，浏览器在本地没有命中的情况下请求头中发送一定的校验数据到服务端，
如果服务端数据没有改变浏览器从本地缓存响应，返回304，
快速，发送的数据很少，只返回一些基本的响应头信息，数据量很小，不发送实际响应体；
3xx一般表示重定向， 但304确切表示的是缓存， 
用304缓存时， 都需要服务器给客户端一个代表资源新旧的东西，一种是last-modified, 一种是etag. 
 


* 200 OK：以上两种缓存全部失败，服务器返回完整响应，没有用到缓存，相对最慢。

## 缓存开关
缓存开关是： pragma， cache-control。

缓存控制：控制缓存的开关，用于标识请求或访问中是否开启了缓存，使用了哪种缓存方式。

缓存控制
在http中，控制缓存开关的字段有两个：Pragma 和 Cache-Control。

### Pragma
Pragma有两个字段Pragma和Expires。Pragma的值为no-cache时，表示禁用缓存，Expires的值是一个GMT时间，表示该缓存的有效时间。
Pragma是旧产物，已经逐步抛弃，有些网站为了向下兼容还保留了这两个字段。如果一个报文中同时出现Pragma和Cache-Control时，以Pragma为准。同时出现Cache-Control和Expires时，以Cache-Control为准。即优先级从高到低是 Pragma -> Cache-Control -> Expires

### Cache-Control
在介绍之前，先啰嗦两个容易忽视的地方：

符合缓存策略时，服务器不会发送新的资源，但不是说客户端和服务器就没有会话了，客户端还是会发请求到服务器的。
Cache-Control除了在响应中使用，在请求中也可以使用。我们用开发者工具来模拟下请求时带上Cache-Control：勾选Disable cache，刷新页面，可以看到Request Headers中有个字段Cache-Control: no-cache。


优先级：pragma >cache-control > expires。
当浏览器没有命中本地缓存，如本地缓存过期或者响应中声明不允许直接使用本地缓存，那么浏览器肯定会发起服务端请求；

Cache-Control的取值：
* no-cache   
不允许直接使用本地缓存，先发起请求和服务器协商；max-age=delta-seconds：告知浏览器该响应本地缓存有效的最长期限，以秒为单位；
可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用 
* no-store 彻底得禁用缓冲，本地和代理服务器都不缓冲，每次都从服务器获取
## 缓存校验
缓存校验：如何校验缓存，比如怎么定义缓存的有效期，怎么确保缓存是最新的。
缓存校验有：Expires，Last-Modified，etag。
### 1. Expires
在缓存中，我们需要一个机制来验证缓存是否有效。比如服务器的资源更新了，客户端需要及时刷新缓存；又或者客户端的资源过了有效期，但服务器上的资源还是旧的，此时并不需要重新发送。缓存校验就是用来解决这些问题的，在http 1.1 中，我们主要关注下Last-Modified 和 etag 这两个字段。

### 2. Last-Modified
服务器的响应会包括last-modified, 是文件的最新修改时间， 以秒为单位， 
后面浏览器每次请求时， 都会在if-modified-since字段带上这个时间，如果浏览器时间小于这个时间， 

具体步骤为：  
*  1.服务端在返回资源时，会将该资源的最后更改时间通过Last-Modified字段返回给客户端。
*  2.客户端下次请求时通过If-Modified-Since或者If-Unmodified-Since带上Last-Modified，
*  3.服务端检查该时间是否与服务器的最后修改时间一致：
  (1)如果一致，则返回304状态码，不返回资源； 
  (2)如果不一致则返回200和修改后的资源，并带上新的时间。

If-Modified-Since和If-Unmodified-Since的区别是：
If-Modified-Since：告诉服务器如果时间一致，返回状态码304
If-Unmodified-Since：告诉服务器如果时间不一致，返回状态码412

### 3. etag
ETag：HTTP1.1推出，文件的指纹标识符，如果文件内容修改，指纹会改变；
单纯的以修改时间来判断还是有缺陷，比如文件的最后修改时间变了，但内容没变。对于这样的情况，我们可以使用etag来处理。
etag的方式是这样：服务器通过某个算法对资源进行计算，取得一串值(类似于文件的md5值)，之后将该值通过etag返回给客户端，客户端下次请求时通过If-None-Match或If-Match带上该值，服务器对该值进行对比校验：如果一致则不要返回资源。
If-None-Match和If-Match的区别是：
If-None-Match：告诉服务器如果一致，返回状态码304，不一致则返回资源
If-Match：告诉服务器如果不一致，返回状态码412


## 缓存策略
缓存策略的选择：
适合缓存的内容：不变的图像，如logo，图标等，js，css静态文件，可下载的内容，媒体文件；

建议使用协商缓存：html文件，

经常替换的图片，经常修改的js，css文件，js和css文件的加载可以加入文件的签名来拒绝缓存，如a.css?签名或a.签名.js；不建议缓存的内容：用户隐私等敏感数据，经常改变的api数据接口

协商缓存相关配置：Etag指令：指定签名；etag on|off;，默认是on