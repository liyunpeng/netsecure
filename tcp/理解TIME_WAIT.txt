 发起关闭的一方，和接收关闭的一方， 会根据接收信号的不同， 进入不同的状

态。 
 A设为发起关闭的一方， B设置为接收关闭的一方。 
Tcp的连接是双向的， 所以有从A到B的连接， 和从B到A的连接， 
四次握手就是为了安全的关闭这两个连接。 
A先发出FIN包， 
这时A进入FN_WAIT_1状态，  状态都是处于两个信号之间的， 
A在发出FIN包， 再接收到ACK包之前， 一直处于FN_WAIT_1状态
收到ACK包后， A就进入FN_WAIT_2状态
B随后在发送FIN包， 而不是像建立连接的三次握手一样， 将ACK和SYN放在一个包里， 发送过来， 
是因为B在手到FIN信号后，这种连接关闭的信号， B要做一些处理， 
B发送ACK后， 就表示从A到B的连接就关闭释放了。 叫做半连接状态。 
还有从B到A的连接， B要做些事情， 再去开启从B到A的连接， 然后B发送FIN包， 
开始做关闭从B到A的连接动作。 
（不生恶念， 但我要精进， 不可安于现状， 要发誓离开此处， 
寻找适合自己的地方， 精进才是破除我相
） 先发一个FIN, A再接到FIN之后 就会立即发送ACK， A发出ACK后， 就进入

TIME_WAIT状态，  不管什么情况， A都会进入TIME_WAIT状态， 而且也不管任何

情况， 这个状态， 都胡持续2msl, msl值报文在网路中的最大存货时间， 不同系

统，对msl的定义不同， windowsw为2分钟， centos, ubuntu等linux系统为60秒

， 之所以要在TIME_WAIT状态维持2Msl时间， 是为了应对ACK包可能在网路中丢失

的情况， B如果没得到ACK， 会重发Fin， A在TIME_WAIT状态， 就是为了等B重发

的这个FIN， 等待的时间为2MSL, 在这个期间没等到， 就认为B已经成功接收到了

ack, 没有重发FIN。  所以对于发起断开连接的一方， 用netstat -antp可以看到

连接处于TIME_WAIT状态。 linux系统，这个状态维持2分钟。 
