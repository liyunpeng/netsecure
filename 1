



restful ：是一个资源表示的一种规范， 
资源的表示包括资源的位置， 资源的操作， 规范就是对地址和操作的规范， 
资源的地址用http这种网络地址标志， 路径实现树的表示， 用中线， 不能用下划线， 一律小写字母。 

有序集合 用跳表实现， 插入效率高些， 跳表和红黑树树的查询和插入时间复杂度都是O（nlogn）， 
没有采用红黑树， 是因为树的转动， 比较复杂。 


排行榜用有序集合做

移花接木：


正确的做法， 不要用最新的第三方代码，还是原vendor目录下的


死锁， 锁等待超时
发生死锁， 意味着四个条件同时满足了， 
1. 资源的互斥， 只能由一个人使用， 针对这个， 分出不同的锁的级别， 读锁， 和写锁， 读锁是允许写的进程进来。 减少互斥的发生


2. 资源独占， 被占有后， 不能被其他抢占， 有时也叫不可剥夺， 即资源只能被当前持有者释放 ， 其他无权释放， 
针对这个特点， 资源的锁， 可以设置一个最大时间， 这是redis分布式锁， 经常用的做法， 以此防止死锁， 

3.资源保持， 即被占有后， 会被保持一段时间， 针对这一点， 措施是， 对资源的操作尽可能的短和快， 
这类似于事务， 事务里的动作要尽可能的少。 

4. 资源的相互等待，进入资源的锁 被对方持有， 针对这个， 措施是对资源的操作， 保证相同的顺序 ， 
比如事务一对记录A， 记录B的顺序， 事务二也要先操作记录A，后操作记录B的顺序。 


续：
当删除或修改数据时，innodbe引擎会自动上锁。即 where 后面的列要上锁。 
这个列， 根据索引的类型， 是否为索引，锁的范围会不同。 
如果这个列是聚集索引， 聚集索引的实现是B+树， 叶子节点包含了一行的所有列。 
锁住这个B+树的一个叶子节点行， 所以只锁一次

如果是二级索引， 除聚集索引其他索引， 都可以叫做二级索引， 
因为二级索引存放的索引值和聚集索引的键值, 不存放其他列值，用这个聚集索引的键到B+树上去找叶子节点， 
所以where 后的列如果是， 二级索引，需要两个枷锁动作。 一个锁二级索引的B树节点， 一个锁聚集索引的B+树节点。 
如果列不是索引， 需要全表扫描过滤， 全表扫描以为着对所有的数据行都加锁。 
所以对于大量数据行的表， where后面的列必须建立索引。 


幻读问题， 不可重复读，是两次读到的同一行不相同。 
幻读 是两次读到的同一提交的行数不相同， 
比如where c = 1, 第一读到了一行， 第二次读到了两行， 在两次读期间， 其他事务增加了一行。 

mysql解决方案， rr级别加gap锁， 原理为，
rr保证了同一行安全的基础上， 对所有where 列的行都加锁， 不允许添加修改， 是对一个范围加锁
比如 where c = 1, 
如果增加的行中列 c = 1, 就会被禁止。 如果要把某一行的列 c改为1， 也会被禁止， 这就是gap锁。 

续:
gap锁， 因为加锁的范围大，增加了死锁的概率， 
如果在业务上能保证一个事务没有第二次读的问题， 就可以把隔离级别从RR降到RC，


oauth：
有几个角色要先说明， 
认证服务器， 
资源服务器， 
用户， 
第三方，有时也叫客户端。 

先说一般登录对身份的签发和验证，  
有jwt和cookie 方式， oauth2是基于jwt方式， 所以这里说下jwt方式， 
第一次登录会生成token， 即令牌， 发给客户端， 客户端js每次请求都在header authorization带上这个token . 

续:
http1.1 新特性：


get 与 post区别：
区别一：
get重点在从服务器上获取资源，post重点在向服务器发送数据；
区别二：
get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用"?"连接，多个请求数据间用"&"连接，如http://127.0.0.1/Test/login.action?name=admin&password=admin，这个过程用户是可见的；
post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；
区别三：
Get传输的数据量小，因为受URL长度限制，但效率较高；
Post可以传输大量数据，所以上传文件时只能用Post方式；
区别四：
get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；
post较get安全性较高；
区别五：
get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。
post支持标准字符集，可以正确传递中文字符。

post的四种方式：



form 
application/x-www-from-urlencoded：
这是默认的方式，juery等js post数据时， 默认采用的方式
只能上传键值对，并且键值对都是间隔分开的。会将表单内的数据转换为键值对

multipart/form-data：
可以提价多个不同类型的数据， 
会生成一个boundary字符串，作为各个部分的分割符， 


既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息；
当上传的字段是文件时，会有Content-Type来说明文件类型；content-disposition，用来说明字段的一些信息

application/json：
JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。

Google 的 AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码：
var data = {'title':'test', 'sub' : [1,2,3]};
$http.post(url, data).success(function(result) {
    ...
});
 

最终发送的请求是：
POST http://www.example.com HTTP/1.1
Content-Type: application/json;charset=utf-8
{"title":"test","sub":[1,2,3]}
这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。一些 php 框架已经开始这么做了。

当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。


text/xml:
关于 XML-RPC（XML Remote Procedure Call）。它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的：
POST http://www.example.com HTTP/1.1 
Content-Type: text/xml

<?xml version="1.0"?>
<methodCall>
    <methodName>examples.getStateName</methodName>
    <params>
        <param>
            <value><i4>41</i4></value>
        </param>
    </params>
</methodCall>
XML-RPC 协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如 WordPress 的 XML-RPC Api，搜索引擎的 ping 服务等等。JavaScript 中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。不过个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。


binary
相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件




http的通用首部，有缓冲控制的conche-control
 请求首部 , 有可以接收的字符集， accept-charset, 和可接收的编码 accept-encoding
 响应首部，
 实体首部


http的问题， 以及https
是文本协议， 传送的报文不被加密，也不被验证完整性， 
默认80端口
htpps是ssl的加密协议， 需要SA公钥证书， 
默认443端口

http发送方从应用层到链路层， 层层加首部， 层层封包， 接收方要层层解包



304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有


四月底前 慢慢更新出来
现实情况， 
现在走的项目， 大家都相互理解。 


将隔离级别从RR调整为RC， 可以降低gap锁引起的死锁问题。 




redis和mysql数据库都有锁的时间超时措施， 
mysql的innodb引擎都谁给每个锁 设置一个innodb_lock_wait_timeout， 
当锁的持有者持有这把锁的时间，  作为锁持有者的事务就会回滚， 
回滚到之前的状态， 这样其他事务就可以拿到这个锁。 




续：
ＲＲgap锁


















受是虚妄的，　苦受　乐受都是虚妄的

忘记了头痛是什么境界。　

虽然这一切，都和我无关，
但还是我选择了这个地方， 

我对我选择的地方， 无能为力， 

深深的无力感

头昏沉沉
各种说话声， 
充斥着这个空间里， 
回想200年前， 忙碌的时刻， 
也是各种忙碌各种说话声， 充斥这个空间 
那些众生有投身何处 
离的很远吗
也许， 
自负， 以自己业力， 
所看到的鸡鸭猪狗
遇到的鸡鸭猪狗， 
就有曾经一起共事的人
眼前的人
若不登上大源船， 
人身一失， 
纵天赋异禀 
还是被业困在生死轮回
而在的人参的几率， 比中五百万还难

轮回， 就是这种温水煮青蛙的， 让人渐渐失去警惕， 
以为这都是正常的事情 
周围人如此 
我也如此。 
五官感受到的都是极粗的东西
一念90茶南，一刹那900生灭
这秽土起来的身体的五官极粗极浊极我恶
我
我登上大源船， 
受的苦不会
很多了， 
而不上船的， 将要受的苦， 

不能被



go sso: 
https://github.com/KenmyZhang/single-sign-on
enmyZhang/sin
