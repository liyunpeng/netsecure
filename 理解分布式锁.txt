
进程内的锁， 只能对本进程里起的线程或携程有效， 不能锁住其他进程。 
在分布式系统里， 会有多个服务进程，这些服务进程可能会访问数据库的同一条

记录， 进程之间需要上锁， 也是谁先抢到了锁， 谁就进入这个共享资源区域， 
进程里的锁因为只有本进程才有效， 所以不能使用在多进程之间上锁的情况， 需

要独立于进程的对象， 来作为锁。 这个锁就叫分布式锁，一般用redis来实现这

个锁。  setnx 表示 set if not exist. 
key如果已经存在，不可设置， 就返回nil, 
如果不存在， 就可以设置， 返回true.
key又可以被删除。 
利用setnx这个性质， 就可以用他来做锁 
锁 意味着其他等待的进程，线程，要在锁外盲等。 要在那轮询，不断重试
所以这里就可以设计，返回true, 就获得了锁，返回false, 表示其他进程已经用

了这个key，还没释放， 就在睡一会， 几秒后在查， 如此不断轮询。 
使用完了共享资源， 就删除key，即释放锁。 

redis这个key, 和 需要上锁的资源，是完全两个不一样的东西， 
key是实现分布锁的一种东西。 资源是分布式锁需呀锁住的东西。 

setnx可以设置超时， 自动删除， 释放锁。 
分布式系统， 集群系统， 微服务系统， 都是多个进程在写作


分布式锁， 当500个线程共同访问同一个id的商品时， 就有锁的问题， 可以锁的策略有：
给整个方法上锁， java用synconized
给一个代码块上锁 
给互斥的id上锁， 这是最合理的， 锁的粒度最小， 
因为锁的范围小，所以可以很快退出锁的区域。 

利用setnx, 
set if not exists 
setnx有