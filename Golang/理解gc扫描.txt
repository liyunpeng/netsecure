gc扫描：
a, b是对象, c是指针， a拥有c， 指的是，a被c指向, 即c=&a
gc按对象扫描， 会把该对象拥有的所有指针都扫描， 指针被扫描到了才会有释放回收等进一步操作。
扫描前， a不拥有c， b拥有C
扫描过程中， 
a先被扫描完， 在扫描b的过程中， go应用程序发生了c=&a的动作，
本来c跟着b被扫描的， 但c不属于b了， 变成属于a了， 而a已经被扫描完， 所以造成了c没被扫描到。
为了解决c扫描不到的问题， gc在扫描前的标记阶段， 启用写屏障， 标记所有指针，避免只依赖对象扫描指针。
