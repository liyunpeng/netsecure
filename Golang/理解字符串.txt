字符串的设计
字符串通常有两种设计，一种是「字符」串，一种是「字节」串。
「字符」串中的每个字都是定长的，而「字节」串中每个字是不定长的。Go 语言里的字符串是「字节」串，英文字符占用 1 个字节，非英文字符占多个字节。这意味着无法通过位置来快速定位出一个完整的字符来，而必须通过遍历的方式来逐个获取单个的字，这个可以是单个的英文字符，也可以是其他语言的一个字，如汉字。
我们所说的字符通常是指 unicode 字符，你可以认为所有的英文和汉字在 unicode 字符集中都有一个唯一的整数编号，一个 unicode 通常用 4 个字节来表示，对应的 Go 语言中的字符 rune 占 4 个字节。在 Go 语言的源码中可以找到下面这行代码，rune 类型是一个衍生类型，它在内存里面使用 int32 类型的 4 个字节存储。
type rune int32
使用「字符」串来表示字符串势必会浪费空间，因为所有的英文字符本来只需要 1 个字节来表示，用 rune 字符来表示的话那么剩余的 3 个字节都是零。但是「字符」串有一个好处，那就是可以快速定位。
下面这张图可以更方便理解字节 byte 和 字符 rune 的关系
Go语言的字符串采用 utf8 编码，中文汉字通常需要占用 3 个字节，英文只需要 1 个字节。len() 函数得到的是字节的数量，通过下标来访问字符串得到的是「字节」。

所以字符串， 是字节流， 而不是字符串流， 

-------------------------------------------------
字符串修改
可以明确的是， go语言没有修改原字符串的方法，字符串都是不可变的，
每次修改，需要字节到字符串，和字符串到字节，两次拷贝， 原字符串和字节数组都是临时的对象， 给gc回收带来压力。 

想修改字符串某给位置的字符， 不能向c语言那样， 直接用字符串的索引下标定位到这个字符， 

必须转为为字节数组， 然后修改字节数组定范下标，来修改这个位置的字节。 
而字符串到字节数组的转换是一种拷贝。 
如果大量的字符串修改，要知道这个拷贝带来的性能影响。
例子： 
	a := "this is string"
	c := []byte(a)  // 字符串转换为字节数组， 这时一个拷贝
	c[0] = 'c'
	d := string(c)  // 字节数组转换为字符串 这是一个拷贝
要修改字符串， 需要两次的拷贝动作。 
得到的d是个原来的c字符串变量是完全两个独立的字符串。 

-------------------------------------------------
字节数组和字符串转换的场景需要
除了要修改字符串外，还有场景：
从网络过来的数据都是字节流， 需要转换为字符串， 
同时， 从本进程传给网络的也需要转换为字节数组，
 
-------------------------------------------------
一个字符串赋值给另一个字符串
每个字符串都有一个头部， 头部包含了字符串的存放地址，和字符串的长度， 和切片类似， 只是比切片少了一个容量的成员。 
一个字符串变量赋值另一个字符串变量， 只是拷贝了一个字符串头部，作为自己的头部，这中拷贝叫做浅拷贝，  共享字符串实体。 

-------------------------------------------------
字符串的分割
var s = "123abc"
var s1 = s[1,3]
结果为23， 
和切片的分割时相同的， 是左闭右开区间。 

-------------------------------------------------
字符串拼接
有几种拼接方法：
+号， fmt.Sprint(), string的join, buffer的write， builder的writestring，具体使用语法为：
s3 = s1 + s2 
 
s3 = fmt.Sprint("%s, %s", s1, s2)
s1 := strings.Join(s,"")
var b bytes.Buffer
	
b.WriteString("昵称")
	b.WriteString(":")

var b strings.Builder
	
b.WriteString("昵称")
	b.WriteString(":")

builder是官方在1.10版本引入的，专门针对之前字符串拼接低效的问题。 
从性能测试结果来，也是build最高效， 171 ns/op  每次操作用时171纳秒
