字符串：
go的字符串， 用utf8编码， 一个英文字符为1个字节， 一个汉字为3个字节 
所以字符串， 是字节流， 而不是字符串流， 

-------------------------------------------------
字符串修改
可以明确的是， go语言没有修改原字符串的方法，字符串都是不可变的，
每次修改，需要字节到字符串，和字符串到字节，两次拷贝， 原字符串和字节数组都是临时的对象， 给gc回收带来压力。 

想修改字符串某给位置的字符， 不能向c语言那样， 直接用字符串的索引下标定位到这个字符， 

必须转为为字节数组， 然后修改字节数组定范下标，来修改这个位置的字节。 
而字符串到字节数组的转换是一种拷贝。 
如果大量的字符串修改，要知道这个拷贝带来的性能影响。
例子： 
	a := "this is string"
	c := []byte(a)  // 字符串转换为字节数组， 这时一个拷贝
	c[0] = 'c'
	d := string(c)  // 字节数组转换为字符串 这是一个拷贝
要修改字符串， 需要两次的拷贝动作。 
得到的d是个原来的c字符串变量是完全两个独立的字符串。 

-------------------------------------------------
字节数组和字符串转换的场景需要
除了要修改字符串外，还有场景：
从网络过来的数据都是字节流， 需要转换为字符串， 
同时， 从本进程传给网络的也需要转换为字节数组，
 
-------------------------------------------------
一个字符串赋值给另一个字符串
每个字符串都有一个头部， 头部包含了字符串的存放地址，和字符串的长度， 和切片类似， 只是比切片少了一个容量的成员。 
一个字符串变量赋值另一个字符串变量， 只是拷贝了一个字符串头部，作为自己的头部，这中拷贝叫做浅拷贝，  共享字符串实体。 

-------------------------------------------------
字符串的分割
var s = "123abc"
var s1 = s[1,3]
结果为23， 
和切片的分割时相同的， 是左闭右开区间。 

-------------------------------------------------
字符串拼接
有几种拼接方法：
+号， fmt.Sprint(), string的join, buffer的write， builder的writestring，具体使用语法为：
s3 = s1 + s2 
 
s3 = fmt.Sprint("%s, %s", s1, s2)
s1 := strings.Join(s,"")
var b bytes.Buffer
	
b.WriteString("昵称")
	b.WriteString(":")

var b strings.Builder
	
b.WriteString("昵称")
	b.WriteString(":")

builder是官方在1.10版本引入的，专门针对之前字符串拼接低效的问题。 
从性能测试结果来，也是build最高效， 171 ns/op  每次操作用时171纳秒
