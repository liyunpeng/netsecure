垃圾回收基本名词：
collector：
collector指的就是垃圾收集器，

mutator：
mutator是指除了垃圾收集器之外的部分，比如说我们应用程序本身。mutator的职责一般是NEW(分配内存),READ(从内存中读取内容),WRITE(将内容写入内存)，而collector则就是回收不再使用的内存来供mutator进行NEW操作的使用。

mutator根对象：
一般指的是分配在堆内存之外，可以直接被mutator直接访问到的对象，一般是指静态/全局变量以及Thread-Local变量(在Java中，存储在java.lang.ThreadLocal中的变量和分配在栈上的变量 - 方法内部的临时变量等都属于此类).

可达对象：
从mutator根对象开始进行遍历，可以被访问到的对象都称为是可达对象。
这些对象也是mutator(你的应用程序)正在使用的对象。

---
常见的垃圾回收方法
1. 引用计数（reference counting）
这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。当引用计数为0时则立即回收对象。
这种方法的优点是实现简单，并且内存的回收很及时。这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，如ios cocoa框架，php，python等。简单引用计数算法也有明显的缺点：
频繁更新引用计数降低了性能。一种简单的解决方法就是编译器将相邻的引用计数更新操作合并到一次更新；还有一种方法是针对频繁发生的临时变量引用不进行计数，而是在引用达到0时通过扫描堆栈确认是否还有临时对象引用而决定是否释放。等等还有很多其他方法，具体可以参考这里。
循环引用问题。当对象间发生循环引用时引用链中的对象都无法得到释放。最明显的解决办法是避免产生循环引用，如cocoa引入了strong指针和weak指针两种指针类型。或者系统检测循环引用并主动打破循环链。当然这也增加了垃圾回收的复杂度。

2. 标记-清除（mark and sweep）
该方法分为两个阶段
1. 标记阶段：找到所有可访问的对象，做个标记
标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；
2. 清除阶段：遍历堆，把未被标记的对象回收
对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）

标记-清除方法解决了引用计数的不足，但是也有比较明显的问题：
(1)每次启动垃圾回收都会暂停当前所有的正常代码执行，回收是系统响应能力大大降低！当然后续也出现了很多mark&sweep算法的变种（如三色标记法）优化了这个问题。
(2)垃圾收集后有可能会造成大量的内存碎片

3. 分代收集（generation）
经过大量实际观察得知，在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为 代（generation）的空间。新创建的对象存放在称为 新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被 提升（promotion）到老年代中。因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。

---
golang一轮完整的GC过程包括6个阶段：
1. Off： 一轮完整的 GC，
	总是从 Off，如果不是Off状态，则代表上一轮GC还未完成，如果这时修改指针的值，是直接修改的。
2. Stack scan: 即扫描，收集根对象（全局变量和 goroutine 栈上的变量），该阶段会开启写屏障(Write Barrier)。
3. Mark: 标记对象，直到标记完所有根对象和根对象可达对象。此时写屏障会记录所有指针的更改(通过 mutator)。
4. Mark Termination: 重新扫描部分全局变量和发生更改的栈变量，完成标记，该阶段会STW(Stop The World)，也是 gc 时造成 go 程序停顿的主要阶段。
5. Sweep: 并发的清除未标记的对象。

---
golang GC采用基于标记-清除的三色标记法:
在上面的Mark 阶段，采用的是三色标记法，
是传统标记-清除算法的一种优化，主要思想是增加了一种中间状态，即灰色对象，以减少 STW 时间。
三色标记将对象分为黑色、白色、灰色三种：
黑色：已标记的对象，表示对象是根对象可达的。
白色：未标记对象，gc开始时所有对象为白色，当gc结束时，如果仍为白色，说明对象不可达，在 sweep 阶段会被清除。
灰色：被黑色对象引用到的对象，但其引用的自对象还未被扫描，灰色为标记过程的中间状态，当灰色对象全部被标记完成代表本次标记阶段结束。

三色标记的主要过程即：
1. 开始时所有对象为白色
2 将所有根对象标记为灰色，放入队列
3. 遍历灰色对象，将其标记为黑色，并将他们引用的对象标记为灰色，放入队列
4. 重复步骤 3 持续遍历灰色对象，直至队列为空
5. 此时只剩下黑色对象和白色对象，白色对象即为下一步需要清除的对象

---
写屏障
在 GC 的流程中，Stack scan 这一步骤，启用了写屏障。写屏障的主要思想，是在标记的过程中，通过写屏障记录发生变化的指针，然后在 Mark termination 的 rescan 过程中，重新进行扫描，因为在这一步骤会 STW，所以在这一步骤完成后的白色对象，不会再被引用，可以直接清除。关于写屏障具体原理和实现，这里不再展开。
例如：
a, b是对象, c是指针， a拥有c， 指的是，a被c指向, 即c=&a
gc按对象扫描， 会把该对象拥有的所有指针都扫描， 指针被扫描到了才会有释放回收等进一步操作。
扫描前， a不拥有c， b拥有C
扫描过程中， 
a先被扫描完， 在扫描b的过程中， go应用程序发生了c=&a的动作，
本来c跟着b被扫描的， 但c不属于b了， 变成属于a了， 而a已经被扫描完， 所以造成了c没被扫描到。
为了解决c扫描不到的问题， gc在扫描前的标记阶段， 启用写屏障， 标记所有指针，避免只依赖对象扫描指针。

---
GC触发
golang 程序的执行过程中，如下几种情况下会触发 GC:
主动触发，用户代码中调用 runtime.GC 会主动触发 GC
默认每 2min 未产生 GC 时，golang 的守护协程 sysmon 会强制触发 GC
当 go 程序分配的内存增长超过阈值时，会触发 GC

---
内存逃逸
逃逸分析是指由编译器决定内存分配的位置，
不需要程序员指定。即由编译器决定新申请的对象会分配到堆上还是栈上。

逃逸分析场景：
1. 指针逃逸
go 将函数内定义的变量返回到函数外，会将本应分配到栈上的内存分配到堆上。
2. 栈空间不足逃逸
当栈空间不足或无法判断当前切片长度时会将对象分配到堆上。
3. 动态类型逃逸
当函数参数为 interface 类型，编译期间无法确定参数的具体类型，也可能会产生逃逸。

---
较少gc压力的编程习惯：
1. 将多个频繁分配的小对象放到一个大对象里

2. 尽量做到对象的重用, 以减少对象的分配 
比如像如下的两个函数定义：
第一个函数没有形参，每次调用的时候返回一个 []byte，第二个函数在每次调用的时候，形参是一个 buf []byte 类型的对象，之后返回读入的 byte 的数目。
第一个函数在每次调用的时候都会分配一段空间，这会给 gc造成额外的压力。第二个函数在每次迪调用的时候，会重用形参声明。

3. 使用字符串时， 尽量用字节数组[]byte, 而不是string。
stirng 与 []byte 之间进行转换，会给 gc 造成压力 通过 gdb，可以先对比下两者的数据结构：
两者发生转换的时候，底层数据结结构会进行复制，因此导致 gc 效率会变低。解决策略上，一种方式是一直使用 []byte，特别是在数据传输方面，[]byte 中也包含着许多 string 会常用到的有效的操作。另一种是使用更为底层的操作直接进行转化，避免复制行为的发生。

4. 用uintptr进行指针运算
unsafe.Pointer 理解成 c++ 中的 void*，在 golang 中，相当于是各种类型的指针进行转化的桥梁。
uintptr 的底层类型是 int，它可以装下指针所指的地址的值。它可以和 unsafe.Pointer 进行相互转化，
主要的区别是：
uintptr 可以参与指针运算，
而 unsafe.Pointer 只能进行指针转化，不能进行指针运算。
想要用 golang 进行指针运算，要先转成 uintptr 的类型，才能进一步计算，比如偏移多少之类的。

5. 字符串拼接
少量使用+连接 string 由于采用 + 来进行 string 的连接会生成新的对象，降低 gc 的效率，
好的方式是通过 append 函数来进行。
如果能提前知道数组的长度的话，最好在最初分配空间的时候就做好空间规划操作，会增加一些代码管理的成本，同时也会降低gc的压力，提升代码的效率。
