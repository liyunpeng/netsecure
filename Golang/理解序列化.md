####  json.MarshalIndent在json.Marshal的基础上格式化输出

比如
```
marshal,_ := json.Marshal(&person)
marshalIndent,_ := json.MarshalIndent(&person, "", "\t")
fmt.Println("\nmarshal:\n",string(marshal), "\n\nmarshalIndent:\n",string(marshalIndent)

打印出来:

marshal:
{"Time":1987,"Name":"liangyongxing","Age":12} 

marshalIndent:
{
    "Time": 1987,
    "Name": "liangyongxing",
    "Age": 12
}
```



### CBOR 
摘要
       简明二进制对象表示（CBOR）是一种数据格式，其设计目标包括极小的代码大小、非常小的消息大小和不需要版本协商的可扩展性。这些设计目标使它不同于早期的二进制序列化，如ASN.1和MessagePack。

1 介绍
结构化数据的二进制表示有数百种标准格式（也称为二进制序列化格式）。其中一些用于特定的信息领域，而另一些则用于任意数据。在IETF中，后一类中最著名的格式可能是ASN.1的BER和DER[ASN.1]。
这里定义的格式遵循一些当前格式无法很好地满足的特定设计目标。基础数据模型是JSON数据模型[RFC4627]的扩展版本。重要的是要注意，这不是一个建议，即通常扩展RFC4627中的语法，因为这样做会导致与已部署的JSON文档存在显著的向后不兼容。相反，这个文档只定义了它自己的数据模型，它从JSON开始。

2 设计目标
CBOR的目标大致按重要性递减的顺序为：

1) 这种表示必须能够明确地编码互联网标准中使用的最常见的数据格式。

*它必须使用二进制编码表示一组合理的基本数据类型和结构。”这里的“合理”在很大程度上受JSON功能的影响，主要是二进制字节字符串的添加。所支持的结构仅限于数组和树；循环图和点阵图不被移植。

*没有要求所有数据格式都是唯一编码的；也就是说，数字“7”可以以多种不同的方式编码是可以接受的。

2) 编码器或解码器的代码必须紧凑，以支持内存、处理器电源和指令集非常有限的系统。

*编码器和解码器需要在非常少量的代码中实现（例如，在[cnn-terms]中定义的类1约束节点中）。

*该格式应使用现代机器表示的数据（例如，不需要二进制到十进制转换）。

3) 数据必须能够在没有模式描述的情况下解码。

*与JSON类似，编码数据应该是自描述的，这样就可以编写通用的解码器。

4) 序列化必须合理地紧凑，但数据紧凑性是编码器和解码器代码紧凑性的第二位。

*这里的“合理”是由JSON作为大小的上界和保持下界的实现复杂性所限定的。使用一般的压缩方案或大量的位处理都会违反复杂性目标。

5) 该格式必须同时适用于受约束的节点和大容量应用程序。

*这意味着在编码和解码方面，CPU的使用必须相当节俭。这既适用于受约束的节点，也适用于数据量非常大的应用程序中的潜在用途。

6) 该格式必须支持所有JSON数据类型，以便在JSON之间进行转换。

*只要表示的数据在JSON的能力范围内，它就必须支持合理的转换级别。必须能够为所有类型的数据定义指向JSON的单向映射。

7) 格式必须是可扩展的，并且扩展数据必须可以被早期的解码器解码。

*这种格式是为几十年的使用而设计的。

*格式必须支持一种允许回退的扩展形式，以便不理解扩展的解码器仍然可以对消息进行解码。

*该格式必须能够在以后的IETF标准中得到扩展。