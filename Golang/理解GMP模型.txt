切换
切换指的是上下文环境的切换。
上下文环境， 相当于执行过程在一个时间点的快照。 对比一下进程， 线程， 协程

---
进程的切换
进程的上下文切换要保存的东西是最多的，堆栈，寄存器，虚拟内存映射，文件句柄。
尤其后面两个，是比较大的时间消耗。 
虚拟内存是虚拟的也和物理内存的对应关系，用户态操作的都是虚拟内存的页。
数据库连接，tcp连接都是文件句柄。
进程切换， 虚拟内存变了，意味者页表缓冲被刷新， 
意味着被切换到的进程的所有的缓存都失效了。
新进程需要对同一块物理内存重新建立页表， 
从磁盘加载到内存缓冲。 
导致切换后的一段时间，系统反应缓慢。
所以服务器应该有不允许有进程切换的机制。
所以服务器都要非常大的内存， 64G， 128G对于服务器都不算高配置，
这就需要redis专门管理这些缓存，设计数据类型等， 
最终目的都是提高缓存命中率，
避免穿透缓存，怼到了数据库上，磁盘数据库操作可是个慢操作， 
所以就算需要更新数据库，也不是由当前业务程序直接更新数据库，
而是采用消息队列，将消息交给下游程序去更新数据库，实现上游程序的异步， 提高吞吐率。像应对瞬时巨量的请求，像面对双十一12点的瞬时爆发访问量， 采用极大内存，一般用大于64G的内存， 
提前把数据放到缓存里，redis和消息中间件在服务器的角色及其重要。
交换页完全被禁止， 如k8s明确禁止交换页。 

---
线程的切换
线程之间共享了虚拟内存映射， 文件句柄， 不需要保存再上下文里。
线程切换前后的虚拟内存还是相同的，需要切换的是堆栈，
线程的堆栈有用户空间的堆栈，大概1Mb左右， 
和内核空间的堆栈，大概几十Kb. 有的叫内核栈，
因为内核栈的操作需要进到内核空间， 需要系统调用进到内核空间， 
进程的切换和线程的切换都是需要系统调用完成的，所以都是操作系统别的。 
线程切换的轻只是相对于进程，耗费成本少一些， 实际还是挺大的。 
系统调用的消耗在高并发的服务器也是应该避免的。
所以在协成出现之前，高并发的操作还是用线程池

---
协程的切换
协成的切换不需要系统调用，是语言级别的。
协程的切换虽然也是切换堆栈， 但这个栈是在用户空间的，不需要进到内核空间， 这是协成切换比线程切换快的一个因素。 

切换的成本直接影响了并发的性能
多并发线程，几个线程协同工作， 一般都是生产者消费者模式， 都会有等待的动作， 
线程用阻塞来等待， 可是阻塞方式并没有释放资源，
并且线程的阻塞和继续运行都后对调度器造成压力。 

所以在线程之上，出现了以非阻塞实现并发协作。 
非阻塞有两种方式：
1. callback方式
代表作是node.js，是一种用javascripts写后端服务的语言， 
好像发挥不了多核的优势， 现在有被淘汰的迹象。 

2. coroutine方式，即协程，最成功的代表作就是go 语言了， 
协成之间用通道通讯，以非阻塞方式实现了阻塞的效果，没有用线程通讯用的共享内存方式通讯。 

非阻塞的等待和携程间的通道通讯，使得协成的切换非常快速的。 
实现了每秒百万级的并发支持。 
目前java 是不支持协成的，java的线程还是基于线程的。
一个语言实现协程需要的技术比较复杂，在此不深究为何java很难做到支持协程。 

go语言因为实现了应用程序的堆栈和本地堆栈的分离，协程可以从一个线程切换到另一个线程。 这样， 当一个协程阻塞的时候， 此协程所在的线程中的其他协程 会调度到另一个线程中去， 而且调用开销很小。 
协程之间共享堆， 不共享栈。 
协程的启动 在使用上，和实现上， 都像调用一个函数一样简单， 主要处理栈。 
再说协程的模型， 以做菜类比
p:  需要的资源， 比如 灶台， 燃气，锅，蔬菜， 食用油
g:  表示菜谱， 即做菜的步骤， 而且维护一个当前做菜过程的状态
m:  表示实际做菜的过程，  要把p和g结合起来， 是一个执行的过程， 类似线程， 但协成是比线程更小的运行单位， 一个进程内若干线程， 一个线程有若干协程。 

---
go协程的模型
g, m, p 的定义都在 runtime/runtime2.go
g是goroutine的缩写， 一个main也是一个goroutine, 可以理解为等待运行或正在运行的任务。
goroutine包括新建，恢复，暂停。
每个g都会放到运行队列里，m会从这个运行队列取出g. m只有把g运行完，或者让g暂停， m才会去队列取下一个g。
g的状态有：
刚被创建还未被初始化的状态idle,
放在运行队列， 还没被m取出的状态runnable
正在被m运行行的状态running
系统调用的执行状态syscall， 此时运行该g的m让出p
等待状态waiting， 不在运行队列， 应该在通道的等待队列
还有两个状态， 待以后理解
type g struct {
}
主要成员：
stack: 栈空间的起始和结束为止
stackguard0：协程的栈的阀值， 超过这个值就要栈扩张了
stackguard1：系统调用的栈的阀值， 超过这个值就要栈扩张了
可见， 协程虽然能系统调用， 但系统调用的栈不会用协程的栈

m是machine的缩写，是运行在机器上的运行实体，目前版本的go来看，一个m就是一个系统线程。
m需要一个p来运行g , p代表运行时需要的资源， m运行的代码分为两部分， 一是go代码， 一是系统调用，
系统调用会阻塞， 这个m也就阻塞了，这个m就会让出p 给其他的m,  所以m的数量不会是一个，
m的数量不能太多，不能太少
m 的描述结构体中没有标记状态的成员
m的情况分为：
拥有P的时候，1. 正在从运行队列获取G， 2. 正在运行G的非系统调用部分，
和没拥有p的时候，1. 运行G中的系统调用部分， 2. m没有需要运行的G， m进入休眠， 放入空闲M链表

p是process的缩写，p是m所独享的资源，在同一个时间点，一个p只能被一个m使用，一个p可以为一个cpu核。
p的数量决定了可以同时执行的m的数量的最大值。
比如p的数量是2， 那么最多有两个m同时运行，可以有超过两个的m存在， 但最多有两个m同时运行。
因为p只能被一个m使用， m内的goroutine可以共享p资源。
P的状态有：
P的状态是随m而动的，
1. 所有的m都休眠了，p会加入空闲p链表，此时为空闲状态idle
2. g在运行状态， 对应m使用的p也在运行状态
3. g在系统调用状态， 对应m使用的p也在系统调用状态
4. gc的stw期间的，p在gcstop状态

每个P都有一个运行队列， g就是要放到这个运行队列， 然后m从这个队列取出m， 运行。
g 有多个运行队列可以选择， 优先选择当前p的运行队列。
关于一个核上到底可以有几个p还有待理解
m去取G时， 也是优先去取当前p的运行队列上的g, 当前p表示当前m所在的核对应的p。

------------------------------------------------------------------------------
函数返回值， 把所有的返回值返回到一个栈中， 如果返回的结构体很大， 会影响性能。
TLS: thread local storage, 代表每个线程的本地数据， 是每个线程所独有的。
TLS的地址存放在FS寄存器里， 线程切换时 ， FS跟着一起切换。
go 访问此寄存器就可得到线程本地数据， 即M的本地数据。

栈扩张：因为每个协程有自己的栈空间，协程可以大量创建， 所以协程刚开始的栈限定为2k
根据需要， 可以在协成运行一段一段时间，扩张栈， 扩张时， 是完全分配一个新栈，然后把旧栈里的内容拷过去。

------------------------------------------------------------------------------
关于M0，G0
M0 是第一个启动的线程
G0
每个协程都有自己专门的G,
有个G0不属于任何应用协程， 而是属于M的
每个M都有自己专有的G0， 因为一个M会有很多G等着他调度， M就把调度哪个G的这个事交给G0来做。


m理解为执行g的线程
sched: 被中断时，保护的现场数据， 包括pc寄存器里的值
atomicstatus:  g的状态标记
链表指针
被中断，重新执行时， 是否需要回到原来的M

m的成员
type m struct {
}
负责调度的g0， 当前正在被运行的g, 当前所拥有的p， 唤醒后重新拥有的p 用nextp表示

p的成员：
p的状态标记， 拥有这个p的m， 内存分配器， g运行的准备出队的队列， g运行的准备入队的队列

---
M结构是Machine，系统线程，它由操作系统管理，goroutine就是跑在M之上的；
M是一个很大的结构，里面维护小对象内存cache（mcache）、
当前执行的goroutine、随机数发生器等等非常多的信息

P结构是Processor，处理器，
它的主要用途就是用来执行goroutine，它维护了一个goroutine队列，即runqueue。
Processor的让我们从N:1调度到M:N调度的重要部分。

G是goroutine实现的核心结构，
它包含了栈，指令指针，以及其他对调度goroutine很重要的信息，例如其阻塞的channel。

Processor的数量是在启动时被设置为环境变量GOMAXPROCS的值，或者通过运行时调度函数GOMAXPROCS()进行设置。Processor数量固定意味着任意时刻只有GOMAXPROCS个线程在运行着go代码


正常情况下
所有的goroutine运行在同一个M系统线程中，每一个M系统线程维护一个Processor，
任何时刻，一个Processor中只有一个goroutine，其他goroutine在runqueue中等待。
一个goroutine运行完自己的时间片后，让出上下文，回到runqueue中。 多核处理器的场景下，为了运行goroutines，每个M系统线程会持有一个Processor。

如果两个M都在一个CPU上运行，这就是并发；
如果两个M在不同的CPU上运行，这就是并行。
在正常情况下，scheduler（调度器）会按照上面的流程进行调度，
当一个G（goroutine）的时间片结束后将P（Processor）分配给下一个G，
但是线程会发生阻塞等情况，看一下goroutine对线程阻塞等的处理。

线程阻塞
当正在运行的goroutine（G0）阻塞的时候，例如进行系统调用，
会再创建一个系统线程（M1)，当前的M0线程放弃了它的Processor（P），P转到新的线程中去运行。


runqueue执行完成
当其中一个Processor的runqueue为空，没有goroutine可以调度，
它会从另外一个上下文偷取一半的goroutine。


首先创建一个G对象，G对象保存到P本地队列或者是全局队列。
P此时去唤醒一个M。
P继续执行它的执行序。
M寻找是否有空闲的P，如果有则将该G对象移动到它本身。
接下来M执行一个调度循环(调用G对象->执行->清理线程→继续找新的Goroutine执行)。
M执行过程中，随时会发生上下文切换。
当发生上线文切换时，需要对执行现场进行保护，以便下次被调度执行时进行现场恢复。
Go调度器M的栈保存在G对象上，
只需要将M所需要的寄存器(SP、PC等)保存到G对象上就可以实现现场保护。
当这些寄存器数据被保护起来，就随时可以做上下文切换了，
在中断之前把现场保存起来。如果此时G任务还没有执行完，
M可以将任务重新丢到P的任务队列，等待下一次被调度执行。当再次被调度执行时，
M通过访问G的vdsoSP、vdsoPC寄存器进行现场恢复(从上次中断位置继续执行)。