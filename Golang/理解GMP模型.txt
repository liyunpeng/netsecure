 协程
先上下文切换。
上下文环境， 相当于执行过程在一个时间点的快照。  对比一下进程， 线程， 协程

进程的上下文切换要保存的东西是最多的，堆栈，寄存器， 虚拟内存映射， 文件句柄， 尤其后面两个， 是比较大的消耗。 虚拟内存是虚拟的也和物理内存的对应关系，  用户态操作的都是虚拟的页
 。数据库连接，tcp连接都是文件句柄。进程切换， 虚拟内存变了，意味者页表缓冲被刷新， 意味着被切换到的进程的所有的缓存都失效了。新进程需要对同一块物理内存重新建立页表， 从磁盘加载到内存缓冲。 导致切换后的一段时间，系统反应缓慢。 
 所以服务器应该有不允许有进程切换的机制。  所以服务器都要非常大的内存， 64G， 128G对于服务器都不算高配置，这就需要redis专门管理这些缓存， 设计数据类型等， 最终目的都是提供魂村命中率， 避免穿透缓存，怼到了数据库上，磁盘数据库操作可是个慢操作， 所以就算需要跟新数据库， 一般也采用消息队列，消息交给下游程序去更新数据库， 实现上游程序的异步， 提高吞吐率。 像应对瞬时巨量的请求，像面对双十一12点的瞬时爆发访问量， 采用极大内存， 1000G有没有， 提前把数据放到缓存里，redis和消息中间件在服务器的角色及其重要， 交换页完全被禁止。 k8s明确禁止交换页。 

线程的切换 线程之间共享了虚拟内存映射， 文件句柄， 不需要保存再上下文里。线程切换前后的虚拟内存还是相同的。  需要切换的是栈，
线程的堆栈有用户空间的堆栈，大概1Mb左右， 和内核空间的堆栈， 大概几十Kb.   有的叫内核栈， 需要系统调用进到内核空间， 这个时间消耗在高并发的服务器也是应该避免的。 

所以进程的切换和线程的切换都是需要系统调用完成的， 所以是操作系统界别的。  线程切换只是相对于进程， 耗费成本少一些， 实际还是挺大的。 所以在协成出现之前， 高并发的操作还是用线程池

而协成的切换时语言级别的， 协程的切换虽然也是切换堆栈， 但这个栈是在用户空间的， 不需要进到内核空间， 这是协成切换比线程切换快的一个因素。 

说完切换， 说说并发。 
多并发进程代价太大， 一般不考虑。 
多并发线程，几个线程协同工作， 一般都是生产者消费者模式， 都会有等待的动作， 线程用阻塞来等待， 可是阻塞 并没有释放资源， 并且线程的阻塞和继续运行都后对调度器造成压力。 
在线程之上， 可以用非阻塞的方式实现并发协作。 
一个是callback方式， 代表作是node.js  是一种用javascripts写后端服务的语言， 好像发挥不了多核的优势， 现在有被淘汰的迹象。 
一个是coroutine方式， 即协成， 最成功的代表作就是go 语言了，  协成之间用通道通讯， 以非阻塞方式实现了阻塞的效果， 没有用线程通讯用的共享内存方式通讯。 协成的切换，都是非常快速的。 实现了每秒百万级的并发支持。 
目前java 是不支持协成的， java的线程还是基于线程的。  一个语言实现协程需要的技术比较复杂， 在此不深究为何java很难做到支持协程。 
go语言因为实现了应用程序的堆栈和本地堆栈的分离，协程可以从一个线程切换到另一个线程。 这样， 当一个协程阻塞的时候， 此协程所在的线程中的其他协程 会调度到另一个线程中去， 而且调用开销很小。 
协程之间共享堆， 不共享栈。 
协程的启动 在使用上，和实现上， 都像调用一个函数一样简单， 主要处理栈。 
再说协程的模型， 以做菜类比
p:   需要的资源， 比如 灶台， 燃气，锅，蔬菜， 食用油
g:  表示菜谱， 即做菜的步骤， 而且维护一个当前做菜过程的状态
m:  表示实际做菜的过程，  要把p和g结合起来， 是一个执行的过程， 类似线程， 但协成是比线程更小的运行单位， 一个进程内若干线程， 一个线程有若干协程。 


---

g, m, p 的定义都在 runtime/runtime2.go
g是goroutine的缩写， 一个main也是一个goroutine, 可以理解为等待运行或正在运行的任务。
goroutine包括新建，恢复，暂停。
每个g都会放到运行队列里，m会从这个运行队列取出g. m只有把g运行完，或者让g暂停， m才会去队列取下一个g。
g的状态有：
刚被创建还未被初始化的状态idle,
放在运行队列， 还没被m取出的状态runnable
正在被m运行行的状态running
系统调用的执行状态syscall， 此时运行该g的m让出p
等待状态waiting， 不在运行队列， 应该在通道的等待队列
还有两个状态， 待以后理解
type g struct {
}
主要成员：
stack: 栈空间的起始和结束为止
stackguard0：协程的栈的阀值， 超过这个值就要栈扩张了
stackguard1：系统调用的栈的阀值， 超过这个值就要栈扩张了
可见， 协程虽然能系统调用， 但系统调用的栈不会用协程的栈

m是machine的缩写，是运行在机器上的运行实体，目前版本的go来看，一个m就是一个系统线程。
m需要一个p来运行g , p代表运行时需要的资源， m运行的代码分为两部分， 一是go代码， 一是系统调用，
系统调用会阻塞， 这个m也就阻塞了，这个m就会让出p 给其他的m,  所以m的数量不会是一个，
m的数量不能太多，不能太少
m 的描述结构体中没有标记状态的成员
m的情况分为：
拥有P的时候，1. 正在从运行队列获取G， 2. 正在运行G的非系统调用部分，
和没拥有p的时候，1. 运行G中的系统调用部分， 2. m没有需要运行的G， m进入休眠， 放入空闲M链表

p是process的缩写，p是m所独享的资源，在同一个时间点，一个p只能被一个m使用，一个p可以为一个cpu核。
p的数量决定了可以同时执行的m的数量的最大值。
比如p的数量是2， 那么最多有两个m同时运行，可以有超过两个的m存在， 但最多有两个m同时运行。
因为p只能被一个m使用， m内的goroutine可以共享p资源。
P的状态有：
P的状态是随m而动的，
1. 所有的m都休眠了，p会加入空闲p链表，此时为空闲状态idle
2. g在运行状态， 对应m使用的p也在运行状态
3. g在系统调用状态， 对应m使用的p也在系统调用状态
4. gc的stw期间的，p在gcstop状态

每个P都有一个运行队列， g就是要放到这个运行队列， 然后m从这个队列取出m， 运行。
g 有多个运行队列可以选择， 优先选择当前p的运行队列。
关于一个核上到底可以有几个p还有待理解
m去取G时， 也是优先去取当前p的运行队列上的g, 当前p表示当前m所在的核对应的p。

------------------------------------------------------------------------------
函数返回值， 把所有的返回值返回到一个栈中， 如果返回的结构体很大， 会影响性能。

TLS: thread local storage, 代表每个线程的本地数据， 是每个线程所独有的。
TLS的地址存放在FS寄存器里， 线程切换时 ， FS跟着一起切换。
go 访问此寄存器就可得到线程本地数据， 即M的本地数据。

栈扩张：因为每个协程有自己的栈空间，协程可以大量创建， 所以协程刚开始的栈限定为2k
根据需要， 可以在协成运行一段一段时间，扩张栈， 扩张时， 是完全分配一个新栈，然后把旧栈里的内容拷过去。



------------------------------------------------------------------------------
关于M0，G0
M0 是第一个启动的线程
G0
每个协程都有自己专门的G,
有个G0不属于任何应用协程， 而是属于M的
每个M都有自己专有的G0， 因为一个M会有很多G等着他调度， M就把调度哪个G的这个事交给G0来做。


m理解为执行g的线程
sched: 被中断时，保护的现场数据， 包括pc寄存器里的值
atomicstatus:  g的状态标记
链表指针
被中断，重新执行时， 是否需要回到原来的M

m的成员
type m struct {
}
负责调度的g0， 当前正在被运行的g, 当前所拥有的p， 唤醒后重新拥有的p 用nextp表示

p的成员：
p的状态标记， 拥有这个p的m， 内存分配器， g运行的准备出队的队列， g运行的准备入队的队列