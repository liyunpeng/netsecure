通道方向的命名：
通道的方向命名和流的方向命名是一致的：都是以进程的内存为基准的。 
数据进入内存的， 就叫输入， 
如果数据来自于流， 那这个流就叫输入流，
在前面加上数据源头，可得到进一步命名， 比如字符串输入流， 文件输入流，网络输入流
如果数据来自于通道， 那这个通道就叫输入通道。
在前面加上数据类型，可得到进一步命名， 
比如int输入通道，user输入通道，文件对象输入通道

通道方向的表示：
<-： 箭头都是向左的， 不会出现-> 这样向右的箭头
<- chan 表示声明一个输入通道,  就是从这个通道读取数据输入给内存
chan <- 表示声明一个输出通道， 就是内存里的数据输出到这个通道。

--------------------
通道的使用实例：
net tcp连接聊天程序的故事：
go提供了简化版的tcp连接，即net.conn. 
服务端listen, accpet可以建立监听套接字连接，和连接套接字， 客户端dail发起向服务端的连接。 
dial返回， 就建立了客户端服务端的连接， 双方就在这个连接上通讯。 
连接是双向的， 就是连接的双发既可以向连接写数据， 也可以从连接中读数据。 
所以该连接既是个reader, 也是个writer. 
客户端通过io.copy（stdout, conn) 把连接里的数据传到屏幕上， 
通过io.copy(conn, stdio)把命令哈的数据传给这个连接。

服务端会每个客户端建立一个连接， 所以在acccpet放在一个for循环里。 
服务端为每个连接建立一个客户对象， 客户对象里存放客户的名字， 和要发给客户的消息。 因为业务是个聊天室， 每个客户的消息都要广播给其他客户， 

所以 发送给客户消息的成员，要接受到这个广播， 
另一方面， 这个成员要发给连接， 所以设计为通道类型， 通道的输入侧是收集所有广播， 通道的输出侧是发给连接，
收集广播的做法是， 
设计一个全局广播通道， 
广播通道的输入侧：每个连接收到客户数据时， 就把这个数据写入广播通道， 
广播通道的输出侧 遍历所有的客户， 把广播通道里数据写给每个客户的消息通道
因为每个客户的消息通道都在range，从通道读入数据，写出给连接，这样广播的消息就会发给所有客户端

通道的range是通道输入侧很常用的写法， 通道range，程序就会阻塞在那里，通道有数据了， 就会解除阻塞， 如下：
func ouputToConnection(c net.Conn, data <-chan string) {
	for v := range data {
		fmt.Fprintf(c, " %s \r\n", v) //  需要加深理解
	}
}
通道的输出侧，不会用ragne的写法， 都是单独一句写入通道语句。 这个写入通道的语句， 都放在其他通道的range里， 如：
for cli := range clientChans {
	cli.message <- msg
}
for select 即可用于输入侧， 也可用于输出侧，一般用于输入侧。 
3。range遍历通道：
close解除所有通道的阻塞。 

--------------------------
无缓冲的通道与有缓冲的通道
不带缓存:
make(chan 数据类型)
带缓存:
make(chan 数据类型,长度)

例如定义一个带缓存的chan： ch := make(chan int,2) 
这里我们定义个缓存长度为2的chan，当我们已经往chan中写入了2个数据，当再次写入第三个数据的时候就会发送阻塞，直到其他人从该chan中读取了数据，那么才可以再次写入数据，
带缓存的chan类似于一个队列，当队列满的时候是无法写入数据的。 \

不管无缓存通道还是有缓存通道， 在关闭后，是无法写入数据的，但是可以读取，看下两个代码证明的实例：
1. 读取关闭后的无缓存通道，不管通道中是否有数据，返回值都为0，false。
done := make(chan int)
go func() {
    done <- 1
}()
close(done)
for i ：= 1; i <= 3; i++ {
    t, ok := <-done
    fmt.Println(i, ":", t, ok)
}
运行结果：
0 false
0 false
0 false

2、读取关闭的有缓存通道：
读取关闭后的有缓存通道，将缓存数据读取完后，再读取返回值为0和false。
done := make(chan int， 1)
go func() {
   done <- 1
}()
close(done)
for i ：= 1; i <= 3; i++ {
   t, ok := <-done
   fmt.Println(i, ":", t, ok)
}
运行结果：
1 true
0 false
0 false

通道使用完后，必须关闭通道，否则range遍历会出现死锁。
