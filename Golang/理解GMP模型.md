协程的启动 在使用上，和实现上， 都像调用一个函数一样简单， 主要处理栈。 
再说协程的模型， 以做菜类比
p:  需要的资源， 比如 灶台， 燃气，锅，蔬菜， 食用油
g:  表示菜谱， 即做菜的步骤， 而且维护一个当前做菜过程的状态
m:  表示实际做菜的过程，  要把p和g结合起来， 是一个执行的过程， 类似线程， 但协成是比线程更小的运行单位， 一个进程内若干线程， 一个线程有若干协程。 

## GMP 概念
### 1. G 
g, m, p 的定义都在 runtime/runtime2.go
g是goroutine的缩写， 一个main也是一个goroutine, 可以理解为等待运行或正在运行的任务。
goroutine包括新建，恢复，暂停。
每个g都会放到运行队列里，m会从这个运行队列取出g. m只有把g运行完，或者让g暂停， m才会去队列取下一个g。
g的状态有：
刚被创建还未被初始化的状态idle,
放在运行队列， 还没被m取出的状态runnable
正在被m运行行的状态running
系统调用的执行状态syscall， 此时运行该g的m让出p
等待状态waiting， 不在运行队列， 应该在通道的等待队列
还有两个状态， 待以后理解
type g struct {
}
主要成员：
stack: 栈空间的起始和结束为止
stackguard0：协程的栈的阀值， 超过这个值就要栈扩张了
stackguard1：系统调用的栈的阀值， 超过这个值就要栈扩张了
可见， 协程虽然能系统调用， 但系统调用的栈不会用协程的栈

G是goroutine实现的核心结构，
它包含了栈，指令指针，以及其他对调度goroutine很重要的信息，例如其阻塞的channel。

### 2. M 
m是machine的缩写，是运行在机器上的运行实体，目前版本的go来看，一个m就是一个系统线程。
m需要一个p来运行g , p代表运行时需要的资源， m运行的代码分为两部分， 一是go代码， 一是系统调用，
系统调用会阻塞， 这个m也就阻塞了，这个m就会让出p 给其他的m,  所以m的数量不会是一个，
m的数量不能太多，不能太少
m 的描述结构体中没有标记状态的成员
m的情况分为：
* 拥有P的时候，1. 正在从运行队列获取G， 2. 正在运行G的非系统调用部分，
* 和没拥有p的时候，1. 运行G中的系统调用部分， 2. m没有需要运行的G， m进入休眠， 放入空闲M链表

sched: 被中断时，保护的现场数据， 包括pc寄存器里的值
atomicstatus:  g的状态标记
链表指针
被中断，重新执行时， 是否需要回到原来的M

m的成员
type m struct {
}
负责调度的g0， 当前正在被运行的g, 当前所拥有的p， 唤醒后重新拥有的p 用nextp表示

M结构是Machine，系统线程，它由操作系统管理，goroutine就是跑在M之上的；
M是一个很大的结构，里面维护小对象内存cache（mcache）、
当前执行的goroutine、随机数发生器等等非常多的信息

### 3. P 
p是process的缩写，p是m所独享的资源，在同一个时间点，一个p只能被一个m使用，一个p可以为一个cpu核。
p的数量决定了可以同时执行的m的数量的最大值。
比如p的数量是2， 那么最多有两个m同时运行，可以有超过两个的m存在， 但最多有两个m同时运行。
因为p只能被一个m使用， m内的goroutine可以共享p资源。
P的状态有：
P的状态是随m而动的，
* 1. 所有的m都休眠了，p会加入空闲p链表，此时为空闲状态idle
* 2. g在运行状态， 对应m使用的p也在运行状态
* 3. g在系统调用状态， 对应m使用的p也在系统调用状态
* 4. gc的stw期间的，p在gcstop状态

每个P都有一个G运行队列， M从这个队列取出G， 运行。
g 有多个运行队列可以选择， 优先选择当前p的运行队列。
m去取G时， 也是优先去取当前p的运行队列上的g, 当前p表示当前m所在的核对应的p。

p的成员：
p的状态标记， 拥有这个p的m， 内存分配器， g运行的准备出队的队列， g运行的准备入队的队列

P结构是Processor，处理器，
它的主要用途就是用来执行goroutine，它维护了一个goroutine队列，即runqueue。
Processor的让我们从N:1调度到M:N调度的重要部分。
Processor的数量是在启动时被设置为环境变量GOMAXPROCS的值，或者通过运行时调度函数GOMAXPROCS()进行设置。Processor数量固定意味着任意时刻只有GOMAXPROCS个线程在运行着go代码

## G的调度
M0 是第一个启动的线程
每个协程都有自己专门的G,
有个G0不属于任何应用协程， 而是属于M的
每个M都有自己专有的G0， 因为一个M会有很多G等着他调度， M就把调度哪个G的这个事交给G0来做。
### 1. 正常情况下, 一个G的时间片用完， 调度器会调度G队列中的下一个G
所有的goroutine运行在同一个M系统线程中，每一个M系统线程维护一个Processor，
任何时刻，一个Processor中只有一个goroutine在running，其他goroutine在runqueue中等待。
一个goroutine运行完自己的时间片后，让出上下文，回到runqueue中。  
多核处理器的场景下，为了运行goroutines，每个M系统线程会持有一个Processor。
如果两个M都在一个CPU上运行，这就是并发；
如果两个M在不同的CPU上运行，这就是并行。
在正常情况下，调度器按照上面的流程进行调度，
当一个G的时间片结束后将P（Processor）分配给下一个G，

### 2. M阻塞时，会新启动一个M，P在新的M中运行， 调度旗把引起阻塞的G的一下G调度到这个M上 
M被阻塞是因为其运行的G让其进入了阻塞，阻塞的情况有：
系统调用
通道阻塞
网络阻塞
当正在运行的goroutine阻塞的时候，
runtime会再创建一个新的M，当前的M线程会放弃P，这个P会转到新的线程中运行。

### 3. 当前P持有的G运行队列全部执行完毕
当其中一个Processor的runqueue为空，没有goroutine可以调度，
它会从另外一个P上偷取一半的goroutine。

## 协程调度时， 协程的上下文切换 
首先创建一个G对象，G对象保存到P本地队列或者是全局队列。
P此时去唤醒一个M。
P继续执行它的执行序。
M寻找是否有空闲的P，如果有则将该G对象移动到它本身。
接下来M执行一个调度循环(调用G对象->执行->清理线程→继续找新的Goroutine执行)。
M执行过程中，随时会发生上下文切换。
当发生上线文切换时，需要对执行现场进行保护，以便下次被调度执行时进行现场恢复。
Go调度器M的栈保存在G对象上，
只需要将M所需要的寄存器(SP、PC等)保存到G对象上就可以实现现场保护。
当这些寄存器数据被保护起来，就随时可以做上下文切换了，
在中断之前把现场保存起来。如果此时G任务还没有执行完，
M可以将任务重新丢到P的任务队列，等待下一次被调度执行。当再次被调度执行时，
M通过访问G的vdsoSP、vdsoPC寄存器进行现场恢复(从上次中断位置继续执行)。