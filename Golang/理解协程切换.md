切换
切换指的是上下文环境的切换。
上下文环境， 相当于执行过程在一个时间点的快照。 对比一下进程， 线程， 协程

## 进程的切换
进程的上下文切换要保存的东西是最多的，堆栈，寄存器，虚拟内存映射，文件句柄。
尤其后面两个，是比较大的时间消耗。 
虚拟内存是虚拟的也和物理内存的对应关系，用户态操作的都是虚拟内存的页。
数据库连接，tcp连接都是文件句柄。
进程切换， 虚拟内存变了，意味者页表缓冲被刷新， 
意味着被切换到的进程的所有的缓存都失效了。
新进程需要对同一块物理内存重新建立页表， 
从磁盘加载到内存缓冲。 
导致切换后的一段时间，系统反应缓慢。
所以服务器应该有不允许有进程切换的机制。
所以服务器都要非常大的内存， 64G， 128G对于服务器都不算高配置，
这就需要redis专门管理这些缓存，设计数据类型等， 
最终目的都是提高缓存命中率，
避免穿透缓存，怼到了数据库上，磁盘数据库操作可是个慢操作， 
所以就算需要更新数据库，也不是由当前业务程序直接更新数据库，
而是采用消息队列，将消息交给下游程序去更新数据库，实现上游程序的异步， 提高吞吐率。像应对瞬时巨量的请求，像面对双十一12点的瞬时爆发访问量， 采用极大内存，一般用大于64G的内存， 
提前把数据放到缓存里，redis和消息中间件在服务器的角色及其重要。
交换页完全被禁止， 如k8s明确禁止交换页。 

## 线程的切换
线程之间共享了虚拟内存映射， 文件句柄， 不需要保存再上下文里。
线程切换前后的虚拟内存还是相同的，需要切换的是堆栈，
线程的堆栈有用户空间的堆栈，大概1Mb左右， 
和内核空间的堆栈，大概几十Kb. 有的叫内核栈，
因为内核栈的操作需要进到内核空间， 需要系统调用进到内核空间， 
进程的切换和线程的切换都是需要系统调用完成的，所以都是操作系统别的。 
线程切换的轻只是相对于进程，耗费成本少一些， 实际还是挺大的。 
系统调用的消耗在高并发的服务器也是应该避免的。
所以在协成出现之前，高并发的操作还是用线程池

## 协程的切换
协成的切换不需要系统调用，是语言级别的。
协程的切换虽然也是切换堆栈， 但这个栈是在用户空间的，不需要进到内核空间， 这是协成切换比线程切换快的一个因素。 

切换的成本直接影响了并发的性能
多并发线程，几个线程协同工作， 一般都是生产者消费者模式， 都会有等待的动作， 
线程用阻塞来等待， 可是阻塞方式并没有释放资源，
并且线程的阻塞和继续运行都后对调度器造成压力。 

所以在线程之上，出现了以非阻塞实现并发协作。 
非阻塞有两种方式：
1. callback方式
代表作是node.js，是一种用javascripts写后端服务的语言， 
好像发挥不了多核的优势， 现在有被淘汰的迹象。 

2. coroutine方式，即协程，最成功的代表作就是go 语言了， 
协成之间用通道通讯，以非阻塞方式实现了阻塞的效果，没有用线程通讯用的共享内存方式通讯。 

非阻塞的等待和携程间的通道通讯，使得协成的切换非常快速的。 
实现了每秒百万级的并发支持。 
目前java 是不支持协成的，java的线程还是基于线程的。
一个语言实现协程需要的技术比较复杂，在此不深究为何java很难做到支持协程。 
go语言因为实现了应用程序的堆栈和本地堆栈的分离，协程可以从一个线程切换到另一个线程。 这样， 当一个协程阻塞的时候， 此协程所在的线程中的其他协程 会调度到另一个线程中去， 而且调用开销很小。 
协程之间共享堆， 不共享栈。 

