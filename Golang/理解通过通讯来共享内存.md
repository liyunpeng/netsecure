
如果程序设计成通过通信来共享数据的话，那么通信的两端是不是在同一个物理设备上就无所谓了，只有这样才能实现真正的分布式计算。golang就是在向这个方向走，但是路还很长。比如 golang 里常见的 chanch := make(chan int)

go func() {
    n := <-ch
    println(n)
}()

ch <- 123
chan 目前在golang里就是个队列，是个内存的数据结构，一个goroutine往chan里放数据，另一个goroutine从里面取数据，go程序开发者并不关心chan里面是怎么保存和传递数据的，对开发者来说chan就是个goroutine之间的通信管道。如果golang能把chan用TCP/IP来实现，就可以达到跨设备通信的目的，甚至可以用更高速的总线来达到接近内存的性能，这样两个goroutine是可以运行在不同的物理设备上的，他们之间只通过chan通信来达到交换数据的目的，并不关心对方是不是和自己在同一个进程同一个机器上。



---
对于c++程序员来说，简单说就是不在多线程或多进程中共享任何东西（当然常量表还是可以共享的），用复制取代共享。目的是尽可能的避免锁的使用。以前的模型是内存共享，需要通讯的时候只是给对方线程发一个事件通知传过去一个指针。现在则把需要传递的数据复制一份给目标线程从而避免共享内存，因此也就不需要加锁。为了尽可能减小拷贝开销，设计时就必须谨慎选择数据结构，尽量减小拷贝的范围。同时，以前的模型中再烂的设计通常都可以通过一个范围巨大的锁解决。新模型中你得接受线程是并行的而且没有锁。

无锁队列， 可以保证高性能， 低延迟， 没有数据竞争， 代码逻辑上更清晰， 

国内某两个字母的最大型的休闲游戏平台，XXGAME，游戏为了避免逻辑崩溃影响网络链接，十多年前就把网络进程独立出来了，逻辑一个进程，网络一个进程，其实就是大多数架构的 LinkServer / Gate 和业务的关系，网络进程和业务之间使用socket通信即可（Linux2.6以后本地 socket通行有 short cut，性能和本地管道一样，基本等同 两次memcpy）。可XXGame服务端引擎，发明了一个 “牛逼的” 共享内存模块，用共享内存+RingBuffer 来给网络进程和逻辑进程做数据交换用，然后写了一大堆觉得很高明的代码来维护这个东西。听说这套引擎后来还用到了该公司其他牛逼的大型游戏中去了。这里问一句，网卡每秒钟能传输多少数据？内存的带宽是网卡的多少倍？写那么多的代码避免了一到两次memcpy换来把时间从 100降低到 99，却让代码之间充满了各种偶合，飞线，好玩么？十多年前我听说这套架构的时候就笑了，如今十多年过去了，面对那么多新产生的架构方法和设计理念，你们这套模块自己都不敢怎么改了吧？新人都不敢给他们怎么维护了吧？要不怎么我最近听着还有好几个游戏在用这么老的模式呢。


