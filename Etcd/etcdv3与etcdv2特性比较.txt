
1 客户端通信方式 
etcdv3的客户端使用gRPC与server进行通信，
通信的消息协议使用protobuf进行约定，
代替了v2版本的HTTP-json格式，使用二进制替代文本，更加节省空间。
同时gRPC使用的是HTTP/2协议，同一个连接可以同时处理多个请求，
不必像HTTP1.1协议中，多个请求需要建立多个连接 
同时，HTTP/2会对请求的Header和请求数据进行压缩编码，
常见的有Header帧，用于传输Header内容，另外就是Data帧，来传输正文实体 
客户端可以将多个请求放到不同的流中，然后将这些流拆分成帧的形式进行二进制传输，
传输的帧也会有一个编号，因此在一个连接中客户端可以发送多个请求，
减少了连接数，降低了对服务器的压力，
二进制的数据传输格式也会是传输速度更快。

2 KV存储方式
etcd存储的数据是一个K-V格式的存储，

etcdv2的key是一个递归的文件目录结构，
在v3版本中的键改成了扁平化的数据结构，更加简洁，

v3中支持前缀查询，在etcdctl get key时可以加上前缀查询选项--prefix，从而达到v2的目录结构查询效果。

在etcdv2中的数据是一个纯内存的实现，
在etcdv3中的key放在内存中，利用btree进行索引，而将真正的value存放在磁盘中。

3 watch机制
etcdv2中的键被废除以后，
为了能够跟踪key的变化，使用了事件机制进行跟踪，维护键的状态，
来防止被删除掉的后键还能恢复和watch到 
但是有一个滑动窗口的大小限制，如果要获取1000个时间之前的键就获取不到了。
因此etcdv2中通过watch来同步数据不是那么可靠， 
断开连接一段时间后就会导致有可能中间的键的改动获取不到了。

在etcdv3中支持get和watch键的任意的历史版本记录。
另外，v2中的watch本质上还是建立很多HTTP连接，
每一个watch建立一个tcp套接字连接，当watch的客户端过多的时候会大大消耗服务器的资源，
v3版本中的watch可以进行连接复用，多个客户端可以共用相同的TCP连接。

4 键的过期机制
etcdv2中的键的实效是使用TTL机制来实现的，每个有存活时间的键，
客户端必须定期的进行刷新重新设置保证它不被自动删除，
每次刷新同 时还会重新建立连接去更新键。

在etcdv3版本中采用了租约机制进行实现，
每个租约会有一个TTL，然后将一些key附加到租约上，
当租约到期后，附加到它上边的key都会被删除。

利用键的过期机制可以实现服务注册功能，
我们可以将一个服务的域名、IP等信息注册到etcd中，
并 给相应的键设置租约，并在TTL时间内定期维持一个心跳进行刷新。
当服务故障后，心跳消失从而相应的键就会自动删除，
从而实现了服务的注册功能和服务的健康检查功能。

5 etcd的并发操作
在多个客户端并发的读取或者改写一个key的时候就会产生竞争，
因此要保证对键的变更是原子操作，在etcdv2中提供了CAS机制，
每次更新前都会拿键的旧版本与当前版本进行compare比较，然后再决定是否进行swap。
etcdv3中可以将多个操作组成一个事务，
当满足一定的条件的时候事务就会被执行。
