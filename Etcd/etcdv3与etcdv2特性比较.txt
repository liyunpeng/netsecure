
1 客户端通信方式 
etcdv3的客户端使用gRPC与server进行通信，通信的消息协议使用protobuf进行约定，代替了v2版本的HTTP-json格式，使用二进制替代文 
本，更加节省空间。同时gRPC使用的是HTTP/2协议，同一个连接可以同时处理多个请求，不必像HTTP1.1协议中，多个请求需要建立多个连接 
。同时，HTTP/2会对请求的Header和请求数据进行压缩编码，常见的有Header帧，用于传输Header内容，另外就是Data帧，来传输正文实体 
。客户端可以将多个请求放到不同的流中，然后将这些流拆分成帧的形式进行二进制传输，传输的帧也会有一个编号，因此在一个连接中客 
户端可以发送多个请求，减少了连接数，降低了对服务器的压力，二进制的数据传输格式也会是传输速度更快。

2 KV存储方式
etcd存储的数据是一个K-V格式的存储，etcdv2的key是一个递归的文件目录结构，在v3版本中的键改成了扁平化的数据结构，更加简洁，v3 
中支持前缀查询，在etcdctl get key时可以加上前缀查询选项--prefix，从而达到v2的目录结构查询效果。在etcdv2中的数据是一个纯内存 
的实现，在etcdv3中的key放在内存中，利用btree进行索引，而将真正的value存放在磁盘中。

3 watch机制
etcdv2中的键被废除以后，为了能够跟踪key的变化，使用了事件机制进行跟踪，维护键的状态，来防止被删除掉的后键还能恢复和watch到 
，但是有一个滑动窗口的大小限制，那么如果要获取1000个时间之前的键就获取不到了。因此etcdv2中通过watch来同步数据不是那么可靠， 
断开连接一段时间后就会导致有可能中间的键的改动获取不到了。在etcdv3中支持get和watch键的任意的历史版本记录。另外，v2中的watch 
本质上还是建立很多HTTP连接，每一个watch建立一个tcp套接字连接，当watch的客户端过多的时候会大大消耗服务器的资源，v3版本中的 
watch可以进行连接复用，多个客户端可以共用相同的TCP连接。

4 键的过期机制
etcdv2中的键的实效是使用TTL机制来实现的，每个有存活时间的键，客户端必须定期的进行刷新重新设置保证它不被自动删除，每次刷新同 
时还会重新建立连接去更新键。在etcdv3版本中采用了租约机制进行实现，每个租约会有一个TTL，然后将一些key附加到租约上，当租约到 
期后，附加到它上边的key都会被删除。利用键的过期机制可以实现服务注册功能，我们可以将一个服务的域名、IP等信息注册到etcd中，并 
给相应的键设置租约，并在TTL时间内定期维持一个心跳进行刷新。当服务故障后，心跳消失从而相应的键就会自动删除，从而实现了服务的 
注册功能和服务的健康检查功能。

5 etcd的并发操作
在多个客户端并发的读取或者改写一个key的时候就会产生竞争，因此要保证对键的变更是原子操作，在etcdv2中提供了CAS机制，每次更新 
前都会拿键的旧版本与当前版本进行compare比较，然后再决定是否进行swap。etcdv3中可以将多个操作组成一个事务，当满足一定的条件的 
时候事务就会被执行。
