
 
vue 里的js语法：
每条语句后面不能有分号，比如import语句末尾不能有分号， 
赋值语句不嫩更有分号， 
数组最后一个元素不能有逗号。 
论做牵头 开局，定局的人








-------------------


变量的定义方式：
全局变量：
var ChanStop = make( chan bool)
make并不是一个函数， 如果用一个函数给全局变量赋值，则语法错误：
var ChanStop = func1( chan bool) 这是语法错误
var Pointerfoo = map[string]int{}
var (
	messages    = make(chan string)
	clientChans = make(map[ClientInfo]bool)
)

常量：
const (
	numElements = 10000000
)




io.Copy


closewrite. 


iris log打印：



vue 的语法：




----------------
软件包javax.servlet不存在的解决办法：

从tomcat lib目录下拷贝一个servlet-api.jar的包到“JDK\jre\lib\ext”目录下
凡是出现找不到包的情况，都可以将找到的包放到JDK\jre\lib\ext下，

-----------------------
命令行乱码：
chcp 65001
chcp 936

------------------



消息系统里的消息堆积的实际问题：

不执安逸相

不执结果相

不执精进相 ， 在精进， 不认为在精进

看世间一切相，都是虚妄的，如何， 都加一个虚妄两个字如何。 




身份认证有cookie和jwt方式
cookie方式：
sessionid 存入cookie, 代表客户身份： 
每次客户在登录时， 都会调用sessiont.start：
func (s *Sessions) Start(ctx context.Context, cookieOptions ...context.CookieOption) *Session {
	cookieValue := s.decodeCookieValue(GetCookie(ctx, s.config.Cookie))

	if cookieValue == "" { // cookie doesn't exist, let's generate a session and set a cookie.
		sid := s.config.SessionIDGenerator(ctx)

		sess := s.provider.Init(sid, s.config.Expires)
		sess.isNew = s.provider.db.Len(sid) == 0

		s.updateCookie(ctx, sid, s.config.Expires, cookieOptions...)

		return sess
	}

	return s.provider.Read(cookieValue, s.config.Expires)
}
 获取一个sessionid, 然后把这个sessionid 设置一个cookie, 这个oookie就会被写入客户端的浏览器中， 
这样每次客户浏览器在发送请求时， 都后有这个cookie， 这个动作时浏览器默认行为， 服务器在浏览器请求的处理里， 在调用具体的seesintkey值时， 都胡用sessinid 和  这个key拼接起来， 
得到一个redis的key. 比如， sessionid 为123456778， sessin的key为username, 则存放这个session的redis的key为：123456778-username.  
session.get(key )会自动做这个拼接， 如：
func (c *OrderController) Get() mvc.Result {
	if len(c.Session.GetString(util.SessionUserName)) > 0 {
不同ip主机发来的请求， 都胡走这个函数，但携带的cookie里的sessionid不同， 英程程序代码不需要区分不同不同的用户， 用sessiondid和sessionkey拼接出的key自动区分了不同用户。 
 


------------------- 
session的存储： 
session可以用mysql数据库， 也可以用redis， 因为session都有一个时限，和访问的频繁性， 一般用redis来存储。 session存储：
sessionMangage是对所有session的一个管理， 可以在素有需要sessin回话的地方， 调用start， 创建sessionid， 和相应的cookie. 
resssion的存储都是用sessioid 和key拼接的， 
不是采用对象的方式， 而是采用key字符串管理的方式， 
这也比较符合redis key的管理， 
key 的名字的构成， 反应了对象和成员的关系， 
比如存储一个用户记录：
key的名字为： 数据库名：用户表名：用户 id。 

redis本身是一个存放在内存里的临时的非关系数据库， 他和硬盘上的关系型数据库有许多不同
key-valude的存放方式， 要使用速度最快的方式， 就是键值对。 
一个key直接找到value. 先要找到这个key-value的地址， 
这是一种典型的查找， 但redis没用采用树查找方式， 因为树相对复杂， 而且内存分布不连续， redis就用了跳表的方式 
redis不是严格意义的数据库， 即：不严格满足 严格的原子性，一致性， 隔离性，  持久性。 
redis不能回滚， 因为回滚回使每次加入一个kv时，会有很多动作， 所以中间出错， 不能回到之前的状态，不具备原子性， 
不具备原子性， 就不具备一致性，因为数据关系不能前后保持一致
因为单线程， 所以是具备隔离性。 
持久化， 有rdb, aof, 和纯内存无持久方式， 
rdb 相当于一个快照， 比较耗时， 一本fork一个进程来做。 

键过期的删除方式 ：
定期删除， 耗费cpu, 惰性删除， 觉得内存不够用时，再删， 耗费内存。 


redis 设计的目的是就快速增删改查数据。 
 


cookie的安全性问题， 
cookie如果被其他主机盗取， 就等于身份被盗取， 一些玩野的js代码都可以盗取访问主机的cookie,  所以coookie要编码加密，

------------------------
jwt身份认证
不同于cookie, jwt身份认证方式， 需要javascripe每次请求时， 都要把jwt写在header里， 这需要显示的写在js程序里， 不像cookie不需要写。 
使用 jwt ，在登录的时候， 会为用户生成tokenm 按指定的secret生成 token：
		if ok := bcrypt.Match(password, user.Password); ok {
			token := jwt.NewTokenWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
				"exp": time.Now().Add(time.Hour * time.Duration(1)).Unix(),
				"iat": time.Now().Unix(),
			})
			tokenString, _ := token.SignedString([]byte("HS2JDFKhu7Y1av7b"))
			oauthToken := new(OauthToken)
			oauthToken.Token = tokenString
			oauthToken.UserId = user.ID
			oauthToken.Secret = "secret"
			oauthToken.Revoked = false
			oauthToken.ExpressIn = time.Now().Add(time.Hour * time.Duration(1)).Unix()
			oauthToken.CreatedAt = time.Now()
			response = oauthToken.OauthTokenCreate()
把这个token存放到数据库， 并返回给客户端 


jwt需要一个secret来生成， 这里创建时用的secret和检查时用的，必须是一个ecretd. :
func JwtHandler() *jwt.Middleware {
	var mySecret = []byte("HS2JDFKhu7Y1av7b")
	return jwt.New(jwt.Config{
		ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) {
			return mySecret, nil
		},
		SigningMethod: jwt.SigningMethodHS256,
	})
}


分布式锁， 当500个线程共同访问同一个id的商品时， 就有锁的问题， 可以锁的策略有：
给整个方法上锁， java用synconized
给一个代码块上锁 
给互斥的id上锁， 这是最合理的， 锁的粒度最小， 
因为锁的范围小，所以可以很快退出锁的区域。 

利用setnx, 
set if not exists 
setnx有



-----------------
