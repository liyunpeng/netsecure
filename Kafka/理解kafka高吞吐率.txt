理解kafka 的快， 快可以理解为高的吞吐率，1秒处理100万个请求，比1秒处理10万个请求，有更高的吞吐率，也就是处理的更快， 快和吞吐率是一个概念。 
成就kafka的快的几个因素：
因素1;  消息的分区的offset保存再消费者， kafka不需要维护这个offset， 决定了kafak的无状态性， 所以很快， 如果有状态， 后一个状态依赖于前一个状态，即依赖于历史数据， 要维护这个状态， 需要一些等待确认的动作， 就会慢下来。 
udp是无状态的， 所以比tcp快。
消息中间件是把消息推给消费者， 还是由消费者拉取消息，不同消息中间件处理不同。 
rabbitmq, 是把消息推给消费， 等待消费者发来确认接收的信号后， 才把消息从消息队列里清除。 
保证不会丢掉消息，  保证安全的同时， 也影响了消息的消费速度

kafka ,选用消费者拉取消息的策略， 消费者仅需要维护一个偏移量，即低于这个偏移量的所有消息都是被消费过的， 消费过的消息什么时候被删除， 还不清楚。

关于消息堆积， 不一定是消费者的消费速速低于生产者发送消息速度， 有时因为消息回滚，
kafka有个会话机制， 会话期内， 生产者在发送消息， 消费者在消费消息， 
会话是由期限的， 消费者在消费一批消息时， 如果超过了会话期限， 
在会话结束时， 会回滚所有消息， 比如消费了100个中的50个， 但会话结束了， 这100个都会回滚。 
这样会话的不断累积， 就会有大量消息堆积。 
如果增加会话期限， 生产者也会更多的消息。
解决的是办法是，确认机制，暂不清楚细节， 待续

因素2：  一个主题下有多个分区， 这些分区会分布在不同的主机上， kafka会选择io执行速度的最快的主机存放， 是负载均衡的处理。 

因素3： 消息会顺序写磁盘，  顺序写磁盘，比随机写磁盘， 速度快好几倍。 
